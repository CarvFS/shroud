.. Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC. 
.. Produced at the Lawrence Livermore National Laboratory 
..
.. LLNL-CODE-738041.
.. All rights reserved. 
..
.. This file is part of Shroud.  For details, see
.. https://github.com/LLNL/shroud. Please also read shroud/LICENSE.
..
.. Redistribution and use in source and binary forms, with or without
.. modification, are permitted provided that the following conditions are
.. met:
..
.. * Redistributions of source code must retain the above copyright
..   notice, this list of conditions and the disclaimer below.
.. 
.. * Redistributions in binary form must reproduce the above copyright
..   notice, this list of conditions and the disclaimer (as noted below)
..   in the documentation and/or other materials provided with the
..   distribution.
..
.. * Neither the name of the LLNS/LLNL nor the names of its contributors
..   may be used to endorse or promote products derived from this
..   software without specific prior written permission.
..
.. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
.. "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
.. LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
.. A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE
.. LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR
.. CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
.. EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
.. PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
.. PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
.. LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
.. NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
.. SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
..
.. #######################################################################

Input
=====

The input to Shroud is a YAML formatted file.
YAML is a human friendly data serialization standard. [yaml]_
Structure is shown through indentation (one or more spaces).  Sequence
items are denoted by a dash, and key value pairs within a map are
separated by a colon::

    library: Tutorial

    declarations:
    - decl: typedef int TypeID

    - decl: void Function1()

    - decl: class Class1
      declarations:
      - decl: void Method1()

Each ``decl`` entry corresponds to a line of C or C++ code.  The top
level ``declarations`` field represents the source file while nested
``declarations`` fields corresponds to curly brace blocks.
The above YAML file represent the source file::

    typedef int TypeID;

    void Function1();

    class Class1
    {
        void Method1();
    }

A ``block`` can be used to group a collection of ``decl`` entires.
Any ``option`` or ``format`` fields will apply to all declarations in
the group::

    declarations:
    - block: True
      options:
        F_name_impl_template: {library}_{undescore_name}
      format:
        F_impl_filename: localfile.f
      declarations:
      - decl: void func1()
      - decl: void func2()

Shroud use curly braces for format strings.
If a string starts with a curly brace YAML
will interpret it as a map/dictionary instead of as part of the
string. To avoid this behavior, strings which start with a curly brace
should be quoted::

    name : "{fmt}"

Strings may be split across several lines by indenting the continued line::

    - decl: void Sum(int len, int *values+dimension+intent(in),
                     int *result+intent(out))

Some values consist of blocks of code.  The pipe, ``|``, is used to indicate that
the string will span several lines and that newlines should be preserved::

    C_invalid_name: |
        if (! isNameValid({cxx_var})) {{
            return NULL;
        }}

Note that to insert a literal ``{``, a double brace, ``{{``, is
required since single braces are used for variable expansion.
``{cxx_var}`` in this example.

Literal newlines, ``/n``, are respected.  Format strings can use a
tab, ``/t``, to hint where it would be convenient to add a
continuation if necessary.  A formfeed, ``/f``, will force a
continuation.  Lines which start with ``0`` are not indented.  This
can be used with labels.  A trailing ``+`` will indent then next line
a level and a leading ``-`` will deindent. Line lengths are controlled
by the options *C_line_length* and *F_line_length* and default to
72.::

    C_invalid_name: |
        if (! isNameValid({cxx_var})) {{+
        return NULL;
        -}}

The only formatting option is to control output line lengths.  This is
required for Fortran which has a maximum line length of 132 in free
form which is generated by shroud.  If you care where curly braces go
in the C source then it is best to set *C_line_length* to a large
number then use an external formatting tool such as ``indent`` or
``uncrustify``.

Customizing Behavior in the YAML file
-------------------------------------

Fields
^^^^^^

A field only applies to the type, enumeration, function, structure or class
to which it belongs.
It is not inherited.
For example, *cxx_header* is a field which is used to define the header file
for class *Names*.  Likewise, setting *library* within a class does not change
the library name.

    library: testnames

    declarations:
      - decl: class Names
        cxx_header: names.hpp
        declarations:
        -  decl: void method1

Options
^^^^^^^

Options are used to customize the behavior of Shroud.
They are defined in the YAML files as a dictionary.
Options can be defined at the global, class, or function level.
Each level creates a new scope which can access all upper level options.
This allows the user to modify behavior for all functions or just a single one::

    options:
      option_a = false
      option_b = false
      option_c = false

    declarations:
    - class: class1
      options:
    #    option_a = false     # inherited
         option_b = true
    #    option_c = false     # inherited
      declarations:
      - decl: void function1
        options:
    #     option_a = false    # inherited
    #     option_b = true     # inherited
          option_c = true

Format
------

A format dictionary contains strings which can be inserted into
generated code.  Generated filenames are also entries in the format
dictionary.  Format dictionaries are also scoped like options.
For example, setting a format in a class also effects all of the 
functions within the class.

How code is formatted
^^^^^^^^^^^^^^^^^^^^^

Format strings contain “replacement fields” surrounded by curly braces
``{}``. Anything that is not contained in braces is considered literal
text, which is copied unchanged to the output. If you need to include
a brace character in the literal text, it can be escaped by doubling:
``{{`` and ``}}``. [Python_Format]_


Attributes
----------

Annotations or attributes apply to specific arguments or results.
They describe semantic behavior for an argument.
An attribute may be set to true by listing its name or
it may have a value in parens::

    - decl: Class1()  +name(new)
    - decl: void Sum(int len, int *values+dimension+intent(in))
    - decl: const std::string getName() +len(30)

Attributes may also be added external to *decl*::

    - decl: void Sum(int len, int *values)
      attrs:
          values:
              dimension: True
              intent: in  
    - decl: const std::string getName()
      fattrs:
          len: 30
  

allocatable
^^^^^^^^^^^

Sometimes it is more convient to have the wrapper allocate an
``intent(out)`` array before passing it to the C++ function.  This can
be accomplished by adding the *allocatable* attribute.  For example the
C++ function ``cos_doubles`` takes the cosine of an ``intent(in)``
argument and assigns it to an ``intent(out)`` argument::

    void cos_doubles(double *in, double *out, int size)
    {
        for(int i = 0; i < size; i++) {
            out[i] = in[i] * 2.;
        }
    }

This is wrapped as::

    decl: void cos_doubles(double * in     +intent(in)  +dimension(:),
                           double * out    +intent(out) +allocatable(mold=in),
                           int      sizein +implied(size(in)))

The *mold* argument is similar to the *mold* argument in the Fortran
``allocate`` statement, it will allocate ``out`` as the same shape as
``in``.  Also notice the use of the *implied* attribute on the
``size`` argument.  This argument is not added to the Fortran API
since its value is *implied* to be the size of argument ``in``.
``size`` is the Fortran intrinsic which returns the number of items
allocated by its argument.

The Fortran wrapper produced is::

    subroutine cos_doubles(in, out)
        use iso_c_binding, only : C_DOUBLE, C_INT
        real(C_DOUBLE), intent(IN) :: in(:)
        real(C_DOUBLE), intent(OUT), allocatable :: out(:)
        integer(C_INT) :: sizein
        allocate(out, mold=in)
        sizein = size(in)
        call c_cos_doubles(in, out, sizein)
    end subroutine cos_doubles

The mold argument was added to the Fortran 2008 standard.  If the
option **F_standard** is not 2008 then the allocate statement will be::

        allocate(out(lbound(in,1):ubound(in,1)))


For Python, same as *dimension*.


default
^^^^^^^

Default value for C++ function argument.
This value is implied by C++ default argument syntax.


deref
^^^^^

List how to dereference pointer arguments or function results.
This is used in conjunction with *dimension* to create arrays.

scalar

    Treat the pointee as a scalar.
    For Python, this will not create a NumPy object.

pointer

    For Fortran, add ``POINTER`` attribute to argument and is associated
    with the argument using ``c_f_pointer``.
    If *owner(caller)* is also defined, add an additional argument
    which is used to release the memory.

    For Python, create a NumPy array.

allocatable

    For Fortran, add ``ALLOCATABLE`` attribute to argument.
    An ``ALLOCATE`` is added and the contents of the C++ argument
    is copied.  If *owner(caller)* is also defined, the C++ argument
    is released.  The caller is responsible to ``DEALLOCATE`` the array.

    For Python, create a NumPy array (same as *pointer*)

raw

    For Fortran, return a ``type(C_PTR)``.

    For Python, return a ``PyCapsule``.

dimension
^^^^^^^^^

Sets the Fortran DIMENSION attribute.
Pointer argument should be passed through since it is an
array.  *value* must be *False*.
If set without a value, it defaults to ``(*)``.

free_pattern
^^^^^^^^^^^^

A name in the **patterns** section which lists code to be used to 
release memory.  Used with function results.
It is used in the *C_memory_dtor_function* and will have the 
variable ``void *ptr`` available as the pointer to the memory
to be released.
See :ref:`MemoryManagementAnchor` for details.

..  and *intent(out)* arguments.


hidden
^^^^^^

The argument will not appear in the Fortran API.
But it will be passed to the C wrapper.
This allows the value to be used in the C wrapper.
For example, setting the shape of a pointer function::

      int * ReturnIntPtr(int *len+intent(out)+hidden) +dimension(len)

.. assumed intent(out)


implied
^^^^^^^
.. assumed intent(in)

The value of an arguments to the C++ function may be implied by other arguments.
If so the *implied* attribute can be used to assign the value to the argument and 
it will not be included in the wrapped API.

Used to compute value of argument to C++ based on argument
to Fortran or Python wrapper.  Useful with array sizes::

      int Sum(int * array +intent(in), int len +implied(size(array))

intent
^^^^^^

Valid valid values are ``in``, ``out``, ``inout``.
If the argument is ``const``, the default is ``in``.


len
^^^

For a string argument, pass an additional argument to the
C wrapper with the result of the Fortran intrinsic ``len``.
If a value for the attribute is provided it will be the name
of the extra argument.  If no value is provided then the
argument name defaults to option *C_var_len_template*.

When used with a function, it will be the length of the return
value of the function using the declaration::

     character(kind=C_CHAR, len={c_var_len}) :: {F_result}

len_trim
^^^^^^^^

For a string argument, pass an additional argument to the
C wrapper with the result of the Fortran intrinsic ``len_trim``.
If a value for the attribute is provided it will be the name
of the extra argument.  If no value is provided then the
argument name defaults to option *C_var_trim_template*.

name
^^^^

Name of the method.
Useful for constructor and destructor methods which have no names.

owner
^^^^^

Specifies who is responsible to release the memory associated with the argument/result.

The terms follow Python's reference counting .  [Python_Refcount]_
The default is set by option *default_owner* which is initialized to *borrow*.

.. new   The caller is responsible to release the memory.

.. borrow  The memory belongs to the C++ library.  Do not release.

caller

   The memory belongs to the user who is responsible to delete it.
   A shadow class must have a destructor wrapped in order to delete 
   the memory.

library

   The memory belongs to the library and should not be deleted by
   the user.
   This is the default value.

.. steal  intent(in)

value
^^^^^

If true, pass-by-value; else, pass-by-reference.
This attribute is implied when the argument is not a pointer or reference.


.. rubric:: Footnotes

.. [Python_Format] `<https://docs.python.org/2/library/string.html#format-string-syntax>`_

.. [Python_Refcount] `<https://docs.python.org/3/c-api/intro.html#reference-count-details>`_

.. [yaml] `yaml.org <http://yaml.org/>`_
