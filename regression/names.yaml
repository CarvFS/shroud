# test template options

copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2019, Lawrence Livermore National Security, LLC.'
-
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
-
- 'All rights reserved.'
-
- 'This file is part of Shroud.'
-
- 'For details about use and distribution, please read LICENSE.'
-
- '#######################################################################'

library: testnames

options:
  debug: True

  # always create wrappers to demonstrate name generation
  F_force_wrapper: True
  wrap_python: True

format:
  C_argument: ARG_
  C_header_filename_suffix: hh
  C_impl_filename_suffix: cc
  F_filename_suffix: F

  C_header_filename: top.h
  C_impl_filename: top.cpp
  F_module_name: top_module
  F_impl_filename: top.f
  LUA_module_name: lua_module_name

declarations:
- decl: |
      enum Color {
        RED,
        BLUE,
        WHITE
      };
  options:
     bar: 4
  format:
     baz: 4  



- decl: class Names
  options:
    none: foo
    C_name_template: XXX_{C_prefix}{class_prefix}{underscore_name}{function_suffix}
    F_C_name_template: XXX_{C_prefix}{class_prefix}{underscore_name}{function_suffix}
  format:
    C_header_filename: foo.h
    C_impl_filename: foo.cpp
    F_module_name: name_module
    F_impl_filename: foo.f
    F_derived_name: FNames

  declarations:
  - decl: void method1()
    format:
      F_name_function: type_method1
  - decl: void method2()
    format:
      C_this: self2
      CXX_this: SH_this2
      F_this:  obj2

# test file suffix
- decl: class Names2
  declarations: []

- block: True
  options:
    C_name_template: YYY_{C_prefix}{underscore_name}{function_suffix}
    F_C_name_template: YYY_{C_prefix}{underscore_name}{function_suffix}
    F_name_impl_template: "{library}_{class_prefix}{underscore_name}{function_suffix}"
  declarations:
  - decl: void function1()
  - decl: void function2()
    format:
      C_name: c_name_special
      F_C_name: f_c_name_special
      F_name_impl: f_name_special

  # test generic/overloaded functions
  - decl: void function3a(int i)
    format:
      F_name_generic: generic3
      F_name_impl: F_name_function3a_int
  - decl: void function3a(long i)
    format:
      F_name_generic: generic3
      F_name_impl: F_name_function3a_long

  # test F_result
  # test C_result  with arg rv
  - decl: int function4(const std::string &rv)

  - decl: void function5() +name(fiveplus)

- decl: namespace ns1
  options:
    # test options in namespace
    F_name_impl_template: "{library_lower}_{class_prefix}{underscore_name}{function_suffix}"
  declarations:
  - decl: void init_ns1()

# Copied from templates.yaml, test replacing generated names
- decl: template<T,U> void FunctionTU(T arg1, U arg2)
  doxygen:
     brief: Function template with two template parameters.
  cxx_template:
  - instantiation: <int, long>
    format:
      C_name: c_name_instantiation1
      F_C_name: f_c_name_instantiation1
      F_name_impl: f_name_instantiation1
      PY_name_impl: PY_name_instantiation1
  - instantiation: <float, double>
    format:
      template_suffix: _instantiation2

# Copied from templates.yaml.
- decl: namespace std
  declarations:
  - decl: template<typename T> class vector
    # std::vector class
    cxx_header: <vector>
    cxx_template:
    - instantiation: <int>
      format:
        # XXX - Necessary to specify lower and upper.
        cxx_class: Vvv1
        class_lower: vvv1
        class_upper: VVV1
        class_scope: 'VvV1::'
        F_derived_name: FFvvv1
    - instantiation: <double>
      format:
        cxx_class: Vvv2
        class_lower: vvv2
        class_upper: VVV2
        class_scope: 'VvV2::'
        F_derived_name: FFvvv2

########################################
# Copied from templates.yaml
# Test class.format.template_suffix
- decl: namespace internal
  declarations:
# Class which is used to instantiate the C++ template.
# It is not part of the Fortran API.
  - decl: class ImplWorker1
    format:
      template_suffix: _instantiation3
    options:
      wrap_fortran: false
      wrap_python: false

- decl: template<typename T> int UseImplWorker()
  doxygen:
     brief: Function which uses a templated T in the implemetation.
  cxx_template:
  - instantiation: <internal::ImplWorker1>

########################################
# Test explicit splicers
# class Name2 has no methods by default it would not be written.
splicer_code:
   c:
     CXX_definitions:
       - // Add some text from splicer
       - // And another line
     class:
       Names2:
         C_definitions:
           - int write_file;
