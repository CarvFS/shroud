***** Fortran/C
root
  c
    char
      *
        in
          buf -- c_char_*_in_buf
          cfi -- c_char_*_in_cfi
        inout
          buf -- c_char_*_inout_buf
          cfi -- c_char_*_inout_cfi
        out
          buf -- c_char_*_out_buf
          cfi -- c_char_*_out_cfi
        result -- c_char_*_result
          buf -- c_char_*_result_buf
            allocatable -- c_char_*_result_buf_allocatable
          cfi -- c_char_*_result_cfi
            allocatable -- c_char_*_result_cfi_allocatable
      **
        in -- c_char_**_in
          buf -- c_char_**_in_buf
      scalar
        in -- c_char_scalar_in
        result -- c_char_scalar_result
          buf -- c_char_scalar_result_buf
          cfi -- c_char_scalar_result_cfi
    mixin
      buf
        result -- c_mixin_buf_result
      cfi
        character
          arg -- c_mixin_cfi_character_arg
          result -- c_mixin_cfi_character_result
    native
      &
        result -- c_native_*/&/**_result
      *
        in
          cdesc -- c_native_*_in/out/inout_cdesc
          cfi -- c_native_*_in_cfi
        inout
          cdesc -- c_native_*_in/out/inout_cdesc
        out
          cdesc -- c_native_*_in/out/inout_cdesc
        result -- c_native_*/&/**_result
          buf -- c_native_*_result_buf
          scalar -- c_native_*_result_scalar
      *&
        out
          buf -- c_native_*&_out_buf
      **
        in -- c_native_**_in
        out
          buf -- c_native_**_out_buf
        result -- c_native_*/&/**_result
    shadow
      ctor -- c_shadow_ctor
      dtor -- c_shadow_dtor
      in -- c_shadow_in
      inout -- c_shadow_inout
      result -- c_shadow_result
      scalar
        ctor -- c_shadow_scalar_ctor
        in -- c_shadow_scalar_in
        result -- c_shadow_scalar_result
    string
      &
        in -- c_string_*/&_in
          buf -- c_string_*/&_in_buf
          cfi -- c_string_scalar/*/&_in_cfi
        inout -- c_string_*/&_inout
          buf -- c_string_*/&_inout_buf
          cfi -- c_string_*/&_inout_cfi
        out -- c_string_*/&_out
          buf -- c_string_*/&_out_buf
          cfi -- c_string_*/&_out_cfi
        result -- c_string_scalar/*/&_result
          buf -- c_string_scalar/*/&_result_buf
            allocatable -- c_string_*/&_result_buf_allocatable
          cfi -- c_string_scalar/*/&_result_cfi
            allocatable -- c_string_*/&_result_cfi_allocatable
      *
        in -- c_string_*/&_in
          buf -- c_string_*/&_in_buf
          cfi -- c_string_scalar/*/&_in_cfi
        inout -- c_string_*/&_inout
          buf -- c_string_*/&_inout_buf
          cfi -- c_string_*/&_inout_cfi
        out -- c_string_*/&_out
          buf -- c_string_*/&_out_buf
          cfi -- c_string_*/&_out_cfi
        result -- c_string_scalar/*/&_result
          buf -- c_string_scalar/*/&_result_buf
            allocatable -- c_string_*/&_result_buf_allocatable
          cfi -- c_string_scalar/*/&_result_cfi
            allocatable -- c_string_*/&_result_cfi_allocatable
      scalar
        in -- c_string_scalar_in
          buf -- c_string_scalar_in_buf
          cfi -- c_string_scalar/*/&_in_cfi
        result -- c_string_scalar/*/&_result
          buf -- c_string_scalar/*/&_result_buf
            allocatable -- c_string_scalar_result_buf_allocatable
          cfi -- c_string_scalar/*/&_result_cfi
            allocatable -- c_string_scalar_result_cfi_allocatable
    struct -- c_struct
      *
        result -- c_struct_*_result
      result -- c_struct_result
    vector
      in
        buf -- c_vector_in_buf
          string -- c_vector_in_buf_string
      inout
        buf -- c_vector_inout_buf
          string -- c_vector_inout_buf_string
      out
        buf -- c_vector_out_buf
          string -- c_vector_out_buf_string
      result
        buf -- c_vector_result_buf
    void
      *
        cdesc -- c_void_*_cdesc
      **
        in -- c_void_**_in
  f
    bool
      in -- f_bool_in
      inout -- f_bool_inout
      out -- f_bool_out
      result -- f_bool_result
    char
      *
        result
          buf
            allocatable -- f_char_scalar/*_result_buf_allocatable
          cfi
            allocatable -- f_char_scalar/*_result_cfi_allocatable
          raw -- f_char_*_result_raw
      scalar
        in -- f_char_scalar_in
        result
          buf
            allocatable -- f_char_scalar/*_result_buf_allocatable
          cfi
            allocatable -- f_char_scalar/*_result_cfi_allocatable
    mixin
      buf
        result -- f_mixin_buf_result
    native
      &
        result -- f_native_&_result
          buf
            pointer -- f_native_&_result_buf_pointer
      *
        in
          cdesc -- f_native_*_in/out/inout_cdesc
        inout
          cdesc -- f_native_*_in/out/inout_cdesc
        out
          allocatable -- f_native_*_out_allocatable
          cdesc -- f_native_*_in/out/inout_cdesc
        result
          buf
            allocatable -- f_native_*_result_buf_allocatable
            pointer -- f_native_*_result_buf_pointer
              caller -- f_native_*_result_buf_pointer_caller
          pointer -- f_native_*_result_pointer
          raw -- f_native_*_result_raw
          scalar -- f_native_*_result_scalar
      *&
        out
          buf
            pointer -- f_native_**/*&_out_buf_pointer
      **
        out -- f_native_**_out
          buf
            pointer -- f_native_**/*&_out_buf_pointer
          raw -- f_native_**_out_raw
        result -- f_native_**_result
    shadow
      ctor -- f_shadow_ctor
      result -- f_shadow_result
    string
      &
        result
          buf
            allocatable -- f_string_scalar/*/&_result_buf_allocatable
          cfi
            allocatable -- f_string_scalar/*/&_result_cfi_allocatable
      *
        result
          buf
            allocatable -- f_string_scalar/*/&_result_buf_allocatable
          cfi
            allocatable -- f_string_scalar/*/&_result_cfi_allocatable
      scalar
        in -- f_string_scalar_in
        result
          buf
            allocatable -- f_string_scalar/*/&_result_buf_allocatable
          cfi
            allocatable -- f_string_scalar/*/&_result_cfi_allocatable
    struct
      *
        result -- f_struct_*_result
          buf
            pointer -- f_struct_*_result_buf_pointer
      scalar
        result -- f_struct_scalar_result
    vector
      inout -- f_vector_inout
        allocatable -- f_vector_inout_allocatable
      out -- f_vector_out
        allocatable -- f_vector_out_allocatable
      result -- f_vector_result
        buf
          allocatable -- f_vector_result_buf_allocatable
    void
      *
        cdesc -- f_void_*_cdesc
        in -- f_void_*_in
        result -- f_void_*_result
      **
        in -- f_void_**_in
        out -- f_void_**_out
c_char_**_in:
  buf_args:
  - arg_decl
  c_arg_decl:
  - char **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent(IN) :: {c_var}(*)'
  f_module:
    iso_c_binding:
    - C_PTR
  name: c_char_**_in
  owner: library
c_char_**_in_buf:
  buf_args:
  - arg_decl
  - size
  - len
  c_arg_decl:
  - char *{c_var}
  c_helper: ShroudStrArrayAlloc ShroudStrArrayFree
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {c_var}(*)'
  f_module:
    iso_c_binding:
    - C_CHAR
  name: c_char_**_in_buf
  owner: library
  post_call:
  - ShroudStrArrayFree({cxx_var}, {c_var_size});
  pre_call:
  - "char **{cxx_var} = ShroudStrArrayAlloc({c_var},\t {c_var_size},\t {c_var_len});"
c_char_*_in_buf:
  buf_args:
  - arg
  - len_trim
  c_helper: ShroudStrAlloc ShroudStrFree
  cxx_local_var: pointer
  name: c_char_*_in_buf
  owner: library
  post_call:
  - ShroudStrFree({cxx_var});
  pre_call:
  - "char * {cxx_var} = ShroudStrAlloc(\t{c_var},\t {c_var_trim},\t {c_var_trim});"
c_char_*_in_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_char_*_in_cfi
  owner: library
  post_call:
  - ShroudStrFree({cxx_var});
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - "char *{cxx_var} = ShroudStrAlloc(\t{c_var},\t {cfi_prefix}{c_var}->elem_len,\t\
    \ -1);"
c_char_*_inout_buf:
  buf_args:
  - arg
  - len_trim
  - len
  c_helper: ShroudStrAlloc ShroudStrCopy ShroudStrFree
  cxx_local_var: pointer
  name: c_char_*_inout_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var},\t -1);"
  - ShroudStrFree({cxx_var});
  pre_call:
  - "char * {cxx_var} = ShroudStrAlloc(\t{c_var},\t {c_var_len},\t {c_var_trim});"
c_char_*_inout_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrAlloc ShroudStrCopy ShroudStrFree
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_char_*_inout_cfi
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {cxx_var},\t -1);"
  - ShroudStrFree({cxx_var});
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - "char *{cxx_var} = ShroudStrAlloc(\t{c_var},\t {cfi_prefix}{c_var}->elem_len,\t\
    \ -1);"
c_char_*_out_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrBlankFill
  name: c_char_*_out_buf
  owner: library
  post_call:
  - ShroudStrBlankFill({c_var}, {c_var_len});
c_char_*_out_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrBlankFill
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_char_*_out_cfi
  owner: library
  post_call:
  - ShroudStrBlankFill({cxx_var}, {cfi_prefix}{c_var}->elem_len);
  pre_call:
  - char *{cxx_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
c_char_*_result:
  name: c_char_*_result
  owner: library
  return_cptr: true
c_char_*_result_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  name: c_char_*_result_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var},\t -1);"
c_char_*_result_buf_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudTypeDefines
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_char_*_result_buf_allocatable
  ntemps: 1
  owner: library
  post_call:
  - '{temp0}->cxx.addr = {cxx_nonconst_ptr};'
  - '{temp0}->cxx.idtor = {idtor};'
  - '{temp0}->addr.ccharp = {cxx_var};'
  - '{temp0}->type = {sh_type};'
  - '{temp0}->elem_len = {cxx_var} == {nullptr} ? 0 : {stdlib}strlen({cxx_var});'
  - '{temp0}->size = 1;'
  - '{temp0}->rank = 0;'
  return_type: void
c_char_*_result_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_char_*_result_cfi
  owner: library
  post_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {cxx_var},\t -1);"
c_char_*_result_cfi_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  f_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {c_var}'
  f_c_arg_names:
  - '{c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_char_*_result_cfi_allocatable
  owner: library
  post_call:
  - if ({cxx_var} != {nullptr}) {{+
  - "int SH_ret = CFI_allocate({cfi_prefix}{c_var}, \t(CFI_index_t *) 0, \t(CFI_index_t\
    \ *) 0, \tstrlen({cxx_var}));"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({cfi_prefix}{c_var}->base_addr, \t{cxx_var}, \t{cfi_prefix}{c_var}->elem_len);"
  - -}}
  - -}}
  return_type: void
c_char_scalar_in:
  buf_args:
  - arg_decl
  c_arg_decl:
  - char {c_var}
  f_arg_decl:
  - 'character(kind=C_CHAR), value, intent(IN) :: {c_var}'
  f_module:
    iso_c_binding:
    - C_CHAR
  name: c_char_scalar_in
  owner: library
c_char_scalar_result:
  f_module:
    iso_c_binding:
    - C_CHAR
  f_result_decl:
  - 'character(kind=C_CHAR) :: {c_var}'
  name: c_char_scalar_result
  owner: library
c_char_scalar_result_buf:
  buf_args:
  - arg
  - len
  impl_header:
  - <cstring>
  name: c_char_scalar_result_buf
  owner: library
  post_call:
  - '{stdlib}memset({c_var}, '' '', {c_var_len});'
  - '{c_var}[0] = {cxx_var};'
c_char_scalar_result_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  name: c_char_scalar_result_cfi
  owner: library
  post_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - '{stdlib}memset({c_var}, '' '', {cfi_prefix}{c_var}->elem_len);'
  - '{c_var}[0] = {cxx_var};'
c_mixin_buf_result:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_mixin_buf_result
  ntemps: 1
  owner: library
  return_type: void
c_mixin_cfi_character_arg:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  cxx_local_var: pointer
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_mixin_cfi_character_arg
  owner: library
  pre_call:
  - char *{cxx_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
c_mixin_cfi_character_result:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_mixin_cfi_character_result
  owner: library
c_native_&_result:
  f_module:
    iso_c_binding:
    - C_PTR
  f_result_decl:
  - type(C_PTR) {c_var}
  name: c_native_&_result
  owner: library
c_native_*&_out_buf:
  arg_call:
  - '{cxx_var}'
  buf_args:
  - context
  c_helper: ShroudTypeDefines
  name: c_native_*&_out_buf
  owner: library
  post_call:
  - '{c_var_context}->cxx.addr  = {cxx_nonconst_ptr};'
  - '{c_var_context}->cxx.idtor = {idtor};'
  - '{c_var_context}->addr.base = {cxx_var};'
  - '{c_var_context}->type = {sh_type};'
  - '{c_var_context}->elem_len = sizeof({cxx_type});'
  - '{c_var_context}->rank = {rank};{c_array_shape}'
  - '{c_var_context}->size = {c_array_size};'
  pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
c_native_**_in:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{cxx_type} **{cxx_var}'
  f_arg_decl:
  - 'type(C_PTR), intent(IN), value :: {c_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: c_native_**_in
  owner: library
c_native_**_out_buf:
  arg_call:
  - '&{cxx_var}'
  buf_args:
  - context
  c_helper: ShroudTypeDefines
  name: c_native_**_out_buf
  owner: library
  post_call:
  - '{c_var_context}->cxx.addr  = {cxx_nonconst_ptr};'
  - '{c_var_context}->cxx.idtor = {idtor};'
  - '{c_var_context}->addr.base = {cxx_var};'
  - '{c_var_context}->type = {sh_type};'
  - '{c_var_context}->elem_len = sizeof({cxx_type});'
  - '{c_var_context}->rank = {rank};{c_array_shape}'
  - '{c_var_context}->size = {c_array_size};'
  pre_call:
  - '{c_const}{cxx_type} *{cxx_var};'
c_native_**_result:
  f_module:
    iso_c_binding:
    - C_PTR
  f_result_decl:
  - type(C_PTR) {c_var}
  name: c_native_**_result
  owner: library
c_native_*_in_cdesc:
  buf_args:
  - context
  name: c_native_*_in_cdesc
  owner: library
  pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_context}->addr.base));"
c_native_*_in_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{c_var}
  cxx_local_var: pointer
  f_arg_decl:
  - '{f_type}, intent({f_intent}) :: {c_var}{f_c_dimension}'
  f_module_line: iso_c_binding:{f_kind}
  iface_header:
  - ISO_Fortran_binding.h
  name: c_native_*_in_cfi
  owner: library
  pre_call:
  - '{cxx_type} *{cxx_var} = {cast_static}{cxx_type} *{cast1}{c_var}->base_addr{cast2};'
c_native_*_inout_cdesc:
  buf_args:
  - context
  name: c_native_*_inout_cdesc
  owner: library
  pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_context}->addr.base));"
c_native_*_out_cdesc:
  buf_args:
  - context
  name: c_native_*_out_cdesc
  owner: library
  pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_context}->addr.base));"
c_native_*_result:
  f_module:
    iso_c_binding:
    - C_PTR
  f_result_decl:
  - type(C_PTR) {c_var}
  name: c_native_*_result
  owner: library
c_native_*_result_buf:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudTypeDefines array_context
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_native_*_result_buf
  ntemps: 1
  owner: library
  post_call:
  - '{temp0}->cxx.addr  = {cxx_nonconst_ptr};'
  - '{temp0}->cxx.idtor = {idtor};'
  - '{temp0}->addr.base = {cxx_var};'
  - '{temp0}->type = {sh_type};'
  - '{temp0}->elem_len = sizeof({cxx_type});'
  - '{temp0}->rank = {rank};{c_array_shape}'
  - '{temp0}->size = {c_array_size};'
  return_cptr: true
  return_type: void
c_native_*_result_scalar:
  f_module_line: iso_c_binding:{f_kind}
  f_result_decl:
  - '{f_type} :: {c_var}'
  name: c_native_*_result_scalar
  owner: library
c_shadow_ctor:
  buf_extra:
  - shadow
  call:
  - "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});"
  - "{shadow_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});"
  - '{shadow_var}->idtor = {idtor};'
  cxx_local_var: pointer
  name: c_shadow_ctor
  owner: caller
  ret:
  - return {shadow_var};
  return_type: '{c_type} *'
c_shadow_dtor:
  call:
  - delete {CXX_this};
  - '{C_this}->addr = {nullptr};'
  impl_header:
  - <cstddef>
  name: c_shadow_dtor
  owner: library
  return_type: void
c_shadow_in:
  buf_args:
  - shadow
  cxx_local_var: pointer
  name: c_shadow_in
  owner: library
  pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}{c_member}addr{cast2};"
c_shadow_inout:
  buf_args:
  - shadow
  cxx_local_var: pointer
  name: c_shadow_inout
  owner: library
  pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}{c_member}addr{cast2};"
c_shadow_result:
  buf_extra:
  - shadow
  c_local_var: pointer
  name: c_shadow_result
  owner: library
  post_call:
  - '{shadow_var}->addr = {cxx_nonconst_ptr};'
  - '{shadow_var}->idtor = {idtor};'
  ret:
  - return {shadow_var};
  return_cptr: true
  return_type: '{c_type} *'
c_shadow_scalar_ctor:
  buf_extra:
  - shadow
  call:
  - "{cxx_type} *{cxx_var} =\t new {cxx_type}({C_call_list});"
  - "{shadow_var}->addr = static_cast<{c_const}void *>(\t{cxx_var});"
  - '{shadow_var}->idtor = {idtor};'
  cxx_local_var: pointer
  name: c_shadow_scalar_ctor
  owner: caller
  ret:
  - return {shadow_var};
  return_type: '{c_type} *'
c_shadow_scalar_in:
  buf_args:
  - shadow
  cxx_local_var: pointer
  name: c_shadow_scalar_in
  owner: library
  pre_call:
  - "{c_const}{cxx_type} * {cxx_var} =\t {cast_static}{c_const}{cxx_type} *{cast1}{c_var}{c_member}addr{cast2};"
c_shadow_scalar_result:
  buf_extra:
  - shadow
  c_local_var: pointer
  cxx_local_var: pointer
  name: c_shadow_scalar_result
  owner: caller
  post_call:
  - '{shadow_var}->addr = {cxx_nonconst_ptr};'
  - '{shadow_var}->idtor = {idtor};'
  pre_call:
  - '{cxx_type} * {cxx_var} = new {cxx_type};'
  ret:
  - return {shadow_var};
  return_cptr: true
  return_type: '{c_type} *'
c_string_&_in:
  cxx_local_var: scalar
  name: c_string_&_in
  owner: library
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
c_string_&_in_buf:
  buf_args:
  - arg
  - len_trim
  cxx_local_var: scalar
  name: c_string_&_in_buf
  owner: library
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_&_in_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudLenTrim
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_&_in_cfi
  owner: library
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - size_t {c_var_trim} = ShroudLenTrim({c_var}, {cfi_prefix}{c_var}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_&_inout:
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  name: c_string_&_inout
  owner: library
  post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
c_string_&_inout_buf:
  buf_args:
  - arg
  - len_trim
  - len
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  name: c_string_&_inout_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var}({c_var}, {c_var_trim});
c_string_&_inout_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_&_inout_cfi
  owner: library
  post_call:
  - "ShroudStrCopy({c_var},\t {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - size_t {c_var_trim} = ShroudLenTrim({c_var}, {cfi_prefix}{c_var}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_&_out:
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  name: c_string_&_out
  owner: library
  post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  pre_call:
  - '{c_const}std::string {cxx_var};'
c_string_&_out_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  name: c_string_&_out_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var};
c_string_&_out_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_&_out_cfi
  owner: library
  post_call:
  - "ShroudStrCopy({c_var},\t {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var};
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
c_string_&_result:
  name: c_string_&_result
  owner: library
  ret:
  - return {c_var};
  return_cptr: true
c_string_&_result_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  name: c_string_&_result_buf
  owner: library
  post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
c_string_&_result_buf_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudStrToArray
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_string_&_result_buf_allocatable
  ntemps: 1
  owner: library
  post_call:
  - "ShroudStrToArray(\t{temp0},\t {cxx_addr}{cxx_var},\t {idtor});"
  return_type: void
c_string_&_result_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_&_result_cfi
  owner: library
  post_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
c_string_&_result_cfi_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  f_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {c_var}'
  f_c_arg_names:
  - '{c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  name: c_string_&_result_cfi_allocatable
  owner: library
  post_call:
  - "int SH_ret = CFI_allocate({cfi_prefix}{c_var}, \t(CFI_index_t *) 0, \t(CFI_index_t\
    \ *) 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({cfi_prefix}{c_var}->base_addr, \t{cxx_var}{cxx_member}data(),\
    \ \t{cxx_var}{cxx_member}length());"
  - -}}
  return_type: void
c_string_*_in:
  cxx_local_var: scalar
  name: c_string_*_in
  owner: library
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
c_string_*_in_buf:
  buf_args:
  - arg
  - len_trim
  cxx_local_var: scalar
  name: c_string_*_in_buf
  owner: library
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_*_in_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudLenTrim
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_*_in_cfi
  owner: library
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - size_t {c_var_trim} = ShroudLenTrim({c_var}, {cfi_prefix}{c_var}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_*_inout:
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  name: c_string_*_inout
  owner: library
  post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  pre_call:
  - '{c_const}std::string {cxx_var}({c_var});'
c_string_*_inout_buf:
  buf_args:
  - arg
  - len_trim
  - len
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  name: c_string_*_inout_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var}({c_var}, {c_var_trim});
c_string_*_inout_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_*_inout_cfi
  owner: library
  post_call:
  - "ShroudStrCopy({c_var},\t {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - size_t {c_var_trim} = ShroudLenTrim({c_var}, {cfi_prefix}{c_var}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_*_out:
  cxx_local_var: scalar
  impl_header:
  - <cstring>
  name: c_string_*_out
  owner: library
  post_call:
  - strcpy({c_var}, {cxx_var}{cxx_member}c_str());
  pre_call:
  - '{c_const}std::string {cxx_var};'
c_string_*_out_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  name: c_string_*_out_buf
  owner: library
  post_call:
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var};
c_string_*_out_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_*_out_cfi
  owner: library
  post_call:
  - "ShroudStrCopy({c_var},\t {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  pre_call:
  - std::string {cxx_var};
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
c_string_*_result:
  name: c_string_*_result
  owner: library
  ret:
  - return {c_var};
  return_cptr: true
c_string_*_result_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  name: c_string_*_result_buf
  owner: library
  post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
c_string_*_result_buf_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudStrToArray
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_string_*_result_buf_allocatable
  ntemps: 1
  owner: library
  post_call:
  - "ShroudStrToArray(\t{temp0},\t {cxx_addr}{cxx_var},\t {idtor});"
  return_type: void
c_string_*_result_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_*_result_cfi
  owner: library
  post_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
c_string_*_result_cfi_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  f_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {c_var}'
  f_c_arg_names:
  - '{c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  impl_header:
  - <cstring>
  name: c_string_*_result_cfi_allocatable
  owner: library
  post_call:
  - "int SH_ret = CFI_allocate({cfi_prefix}{c_var}, \t(CFI_index_t *) 0, \t(CFI_index_t\
    \ *) 0, \t{cxx_var}{cxx_member}length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({cfi_prefix}{c_var}->base_addr, \t{cxx_var}{cxx_member}data(),\
    \ \t{cxx_var}{cxx_member}length());"
  - -}}
  return_type: void
c_string_scalar_in:
  buf_args:
  - arg_decl
  c_arg_decl:
  - char *{c_var}
  f_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {c_var}(*)'
  f_module:
    iso_c_binding:
    - C_CHAR
  name: c_string_scalar_in
  owner: library
c_string_scalar_in_buf:
  buf_args:
  - arg_decl
  - len_trim
  c_arg_decl:
  - char *{c_var}
  call:
  - '{cxx_var}'
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(kind=C_CHAR), intent(IN) :: {c_var}(*)'
  f_module:
    iso_c_binding:
    - C_CHAR
  name: c_string_scalar_in_buf
  owner: library
  pre_call:
  - std::string {cxx_var}({c_var}, {c_var_trim});
c_string_scalar_in_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudLenTrim
  cxx_local_var: scalar
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_scalar_in_cfi
  owner: library
  pre_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - size_t {c_var_trim} = ShroudLenTrim({c_var}, {cfi_prefix}{c_var}->elem_len);
  - '{c_const}std::string {cxx_var}({c_var}, {c_var_trim});'
c_string_scalar_result:
  name: c_string_scalar_result
  owner: library
  ret:
  - return {c_var};
  return_cptr: true
c_string_scalar_result_buf:
  buf_args:
  - arg
  - len
  c_helper: ShroudStrCopy
  name: c_string_scalar_result_buf
  owner: library
  post_call:
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {c_var_len},\t {cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size());"
  - -}}
c_string_scalar_result_buf_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudStrToArray
  cxx_local_var: pointer
  destructor_name: new_string
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_string_scalar_result_buf_allocatable
  ntemps: 1
  owner: library
  post_call:
  - ShroudStrToArray({temp0}, {cxx_var}, {idtor});
  pre_call:
  - std::string * {cxx_var} = new std::string;
  return_type: void
c_string_scalar_result_cfi:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  c_helper: ShroudStrCopy
  f_arg_decl:
  - 'character(len=*), intent({f_intent}) :: {c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_scalar_result_cfi
  owner: library
  post_call:
  - char *{c_var} = {cast_static}char *{cast1}{cfi_prefix}{c_var}->base_addr{cast2};
  - if ({cxx_var}{cxx_member}empty()) {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {nullptr},\t 0);"
  - -}} else {{+
  - "ShroudStrCopy({c_var}, {cfi_prefix}{c_var}->elem_len,\t {cxx_var}{cxx_member}data(),\t\
    \ {cxx_var}{cxx_member}size());"
  - -}}
c_string_scalar_result_cfi_allocatable:
  buf_args:
  - arg_decl
  c_arg_decl:
  - CFI_cdesc_t *{cfi_prefix}{c_var}
  destructor_name: new_string
  f_arg_decl:
  - 'character(len=:), intent({f_intent}), allocatable :: {c_var}'
  f_c_arg_names:
  - '{c_var}'
  iface_header:
  - ISO_Fortran_binding.h
  name: c_string_scalar_result_cfi_allocatable
  owner: library
  post_call:
  - "int SH_ret = CFI_allocate({cfi_prefix}{c_var}, \t(CFI_index_t *) 0, \t(CFI_index_t\
    \ *) 0, \t{cxx_var}.length());"
  - if (SH_ret == CFI_SUCCESS) {{+
  - "{stdlib}memcpy({cfi_prefix}{c_var}->base_addr, \t{cxx_var}.data(), \t{cfi_prefix}{c_var}->elem_len);"
  - -}}
  return_type: void
c_struct:
  cxx_local_var: pointer
  name: c_struct
  owner: library
  pre_call:
  - "{c_const}{cxx_type} * {cxx_var} = \tstatic_cast<{c_const}{cxx_type} *>\t(static_cast<{c_const}void\
    \ *>(\t{c_addr}{c_var}));"
c_struct_*_result:
  c_local_var: pointer
  f_module:
    iso_c_binding:
    - C_PTR
  f_result_decl:
  - type(C_PTR) {c_var}
  name: c_struct_*_result
  owner: library
  post_call:
  - "{c_const}{c_type} * {c_var} = \tstatic_cast<{c_const}{c_type} *>(\tstatic_cast<{c_const}void\
    \ *>(\t{cxx_addr}{cxx_var}));"
c_struct_result:
  c_local_var: pointer
  name: c_struct_result
  owner: library
  post_call:
  - "{c_const}{c_type} * {c_var} = \tstatic_cast<{c_const}{c_type} *>(\tstatic_cast<{c_const}void\
    \ *>(\t{cxx_addr}{cxx_var}));"
c_vector_in_buf:
  buf_args:
  - arg
  - size
  cxx_local_var: scalar
  name: c_vector_in_buf
  owner: library
  pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var}({c_var}, {c_var} + {c_var_size});'
c_vector_in_buf_string:
  buf_args:
  - arg
  - size
  - len
  c_helper: ShroudLenTrim
  cxx_local_var: scalar
  name: c_vector_in_buf_string
  owner: library
  pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * BBB = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_temp}i = 0,
  - '{c_temp}n = {c_var_size};'
  - -for(; {c_temp}i < {c_temp}n; {c_temp}i++) {{+
  - '{cxx_var}.push_back(std::string(BBB,ShroudLenTrim(BBB, {c_var_len})));'
  - BBB += {c_var_len};
  - -}}
  - -}}
c_vector_inout_buf:
  buf_args:
  - arg
  - size
  - context
  c_helper: ShroudTypeDefines
  cxx_local_var: pointer
  destructor_name: std_vector_{cxx_T}
  name: c_vector_inout_buf
  owner: library
  post_call:
  - '{c_var_context}->cxx.addr  = {cxx_var};'
  - '{c_var_context}->cxx.idtor = {idtor};'
  - '{c_var_context}->addr.base = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_context}->type = {sh_type};'
  - '{c_var_context}->elem_len = sizeof({cxx_T});'
  - '{c_var_context}->size = {cxx_var}->size();'
  - '{c_var_context}->rank = 1;'
  - '{c_var_context}->shape[0] = {c_var_context}->size;'
  pre_call:
  - "std::vector<{cxx_T}> *{cxx_var} = \tnew std::vector<{cxx_T}>\t(\t{c_var}, {c_var}\
    \ + {c_var_size});"
c_vector_inout_buf_string:
  buf_args:
  - arg
  - size
  - len
  cxx_local_var: scalar
  name: c_vector_inout_buf_string
  owner: library
  post_call:
  - '{{+'
  - char * BBB = {c_var};
  - std::vector<{cxx_T}>::size_type
  - +{c_temp}i = 0,
  - '{c_temp}n = {c_var_size};'
  - -{c_temp}n = std::min({cxx_var}.size(),{c_temp}n);
  - for(; {c_temp}i < {c_temp}n; {c_temp}i++) {{+
  - "ShroudStrCopy(BBB, {c_var_len},\t {cxx_var}[{c_temp}i].data(),\t {cxx_var}[{c_temp}i].size());"
  - BBB += {c_var_len};
  - -}}
  - -}}
  pre_call:
  - std::vector<{cxx_T}> {cxx_var};
  - '{{+'
  - '{c_const}char * BBB = {c_var};'
  - std::vector<{cxx_T}>::size_type
  - +{c_temp}i = 0,
  - '{c_temp}n = {c_var_size};'
  - -for(; {c_temp}i < {c_temp}n; {c_temp}i++) {{+
  - '{cxx_var}.push_back(std::string(BBB,ShroudLenTrim(BBB, {c_var_len})));'
  - BBB += {c_var_len};
  - -}}
  - -}}
c_vector_out_buf:
  buf_args:
  - context
  c_helper: ShroudTypeDefines
  cxx_local_var: pointer
  destructor_name: std_vector_{cxx_T}
  name: c_vector_out_buf
  owner: library
  post_call:
  - '{c_var_context}->cxx.addr  = {cxx_var};'
  - '{c_var_context}->cxx.idtor = {idtor};'
  - '{c_var_context}->addr.base = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{c_var_context}->type = {sh_type};'
  - '{c_var_context}->elem_len = sizeof({cxx_T});'
  - '{c_var_context}->size = {cxx_var}->size();'
  - '{c_var_context}->rank = 1;'
  - '{c_var_context}->shape[0] = {c_var_context}->size;'
  pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
c_vector_out_buf_string:
  buf_args:
  - arg
  - size
  - len
  c_helper: ShroudLenTrim
  cxx_local_var: scalar
  name: c_vector_out_buf_string
  owner: library
  post_call:
  - '{{+'
  - char * BBB = {c_var};
  - std::vector<{cxx_T}>::size_type
  - +{c_temp}i = 0,
  - '{c_temp}n = {c_var_size};'
  - '{c_temp}n = std::min({cxx_var}.size(),{c_temp}n);'
  - -for(; {c_temp}i < {c_temp}n; {c_temp}i++) {{+
  - "ShroudStrCopy(BBB, {c_var_len},\t {cxx_var}[{c_temp}i].data(),\t {cxx_var}[{c_temp}i].size());"
  - BBB += {c_var_len};
  - -}}
  - -}}
  pre_call:
  - '{c_const}std::vector<{cxx_T}> {cxx_var};'
c_vector_result_buf:
  buf_args:
  - arg_decl
  c_arg_decl:
  - '{C_array_type} *{temp0}'
  c_helper: ShroudTypeDefines
  cxx_local_var: pointer
  destructor_name: std_vector_{cxx_T}
  f_arg_decl:
  - 'type({F_array_type}), intent(OUT) :: {c_var}'
  f_import:
  - '{F_array_type}'
  name: c_vector_result_buf
  ntemps: 1
  owner: library
  post_call:
  - '{temp0}->cxx.addr  = {cxx_var};'
  - '{temp0}->cxx.idtor = {idtor};'
  - '{temp0}->addr.base = {cxx_var}->empty() ? {nullptr} : &{cxx_var}->front();'
  - '{temp0}->type = {sh_type};'
  - '{temp0}->elem_len = sizeof({cxx_T});'
  - '{temp0}->size = {cxx_var}->size();'
  - '{temp0}->rank = 1;'
  - '{temp0}->shape[0] = {temp0}->size;'
  pre_call:
  - "{c_const}std::vector<{cxx_T}>\t *{cxx_var} = new std::vector<{cxx_T}>;"
  return_type: void
c_void_**_in:
  buf_args:
  - arg_decl
  c_arg_decl:
  - void **{c_var}
  f_arg_decl:
  - 'type(C_PTR), intent(IN) :: {c_var}{f_c_dimension}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: c_void_**_in
  owner: library
c_void_*_cdesc:
  buf_args:
  - context
  name: c_void_*_cdesc
  owner: library
  pre_call:
  - "{cxx_type} * {c_var} = static_cast<{cxx_type} *>\t(const_cast<void *>({c_var_context}->addr.base));"
f_bool_in:
  c_local_var: true
  name: f_bool_in
  pre_call:
  - '{c_var} = {f_var}  ! coerce to C_BOOL'
f_bool_inout:
  c_local_var: true
  name: f_bool_inout
  post_call:
  - '{f_var} = {c_var}  ! coerce to logical'
  pre_call:
  - '{c_var} = {f_var}  ! coerce to C_BOOL'
f_bool_out:
  c_local_var: true
  name: f_bool_out
  post_call:
  - '{f_var} = {c_var}  ! coerce to logical'
f_bool_result:
  name: f_bool_result
  need_wrapper: true
f_char_*_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  c_helper: copy_string
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_string array_context
  name: f_char_*_result_buf_allocatable
  need_wrapper: true
  ntemps: 1
  post_call:
  - 'allocate(character(len={temp0}%elem_len):: {f_var})'
  - "call {hnamefunc0}(\t{temp0},\t {f_var},\t {temp0}%elem_len)"
f_char_*_result_cfi_allocatable:
  arg_c_call:
  - '{f_var}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  name: f_char_*_result_cfi_allocatable
  need_wrapper: true
f_char_*_result_raw:
  arg_decl:
  - 'type(C_PTR) :: {f_var}'
  name: f_char_*_result_raw
f_char_scalar_in:
  arg_decl:
  - 'character, value, intent(IN) :: {f_var}'
  name: f_char_scalar_in
f_char_scalar_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  c_helper: copy_string
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_string array_context
  name: f_char_scalar_result_buf_allocatable
  need_wrapper: true
  ntemps: 1
  post_call:
  - 'allocate(character(len={temp0}%elem_len):: {f_var})'
  - "call {hnamefunc0}(\t{temp0},\t {f_var},\t {temp0}%elem_len)"
f_char_scalar_result_cfi_allocatable:
  arg_c_call:
  - '{f_var}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  name: f_char_scalar_result_cfi_allocatable
  need_wrapper: true
f_mixin_buf_result:
  arg_c_call:
  - '{temp0}'
  declare:
  - 'type({F_array_type}) :: {temp0}'
  name: f_mixin_buf_result
  ntemps: 1
f_native_&_result:
  call:
  - '{F_pointer} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_pointer}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  name: f_native_&_result
  post_call:
  - call c_f_pointer({F_pointer}, {F_result}{f_array_shape})
f_native_&_result_buf_pointer:
  arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  call:
  - '{F_pointer} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_pointer}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  name: f_native_&_result_buf_pointer
  post_call:
  - call c_f_pointer({F_pointer}, {F_result}{f_array_shape})
f_native_*&_out_buf_pointer:
  arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  name: f_native_*&_out_buf_pointer
  post_call:
  - call c_f_pointer({c_var_context}%base_addr, {f_var}{f_array_shape})
f_native_**_out:
  arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  name: f_native_**_out
f_native_**_out_buf_pointer:
  arg_decl:
  - '{f_type}, intent({f_intent}), pointer :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  name: f_native_**_out_buf_pointer
  post_call:
  - call c_f_pointer({c_var_context}%base_addr, {f_var}{f_array_shape})
f_native_**_out_raw:
  arg_decl:
  - 'type(C_PTR), intent({f_intent}) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_native_**_out_raw
f_native_**_result:
  arg_decl:
  - 'type(C_PTR) :: {f_var}'
  name: f_native_**_result
f_native_*_in_cdesc:
  arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper: ShroudTypeDefines
  f_module:
    iso_c_binding:
    - C_LOC
  name: f_native_*_in_cdesc
  pre_call:
  - '{c_var_context}%base_addr = C_LOC({f_var})'
  - '{c_var_context}%type = {sh_type}'
  - '! {c_var_context}%elem_len = C_SIZEOF()'
  - '{c_var_context}%size = {size}'
  - '{c_var_context}%rank = {rank}'
  - '{c_var_context}%shape(1:{rank}) = shape({f_var})'
f_native_*_inout_cdesc:
  arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper: ShroudTypeDefines
  f_module:
    iso_c_binding:
    - C_LOC
  name: f_native_*_inout_cdesc
  pre_call:
  - '{c_var_context}%base_addr = C_LOC({f_var})'
  - '{c_var_context}%type = {sh_type}'
  - '! {c_var_context}%elem_len = C_SIZEOF()'
  - '{c_var_context}%size = {size}'
  - '{c_var_context}%rank = {rank}'
  - '{c_var_context}%shape(1:{rank}) = shape({f_var})'
f_native_*_out_allocatable:
  arg_decl:
  - '{f_type}, intent({f_intent}), allocatable :: {f_var}{f_assumed_shape}'
  name: f_native_*_out_allocatable
  pre_call:
  - allocate({f_var}{f_array_allocate})
f_native_*_out_cdesc:
  arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper: ShroudTypeDefines
  f_module:
    iso_c_binding:
    - C_LOC
  name: f_native_*_out_cdesc
  pre_call:
  - '{c_var_context}%base_addr = C_LOC({f_var})'
  - '{c_var_context}%type = {sh_type}'
  - '! {c_var_context}%elem_len = C_SIZEOF()'
  - '{c_var_context}%size = {size}'
  - '{c_var_context}%rank = {rank}'
  - '{c_var_context}%shape(1:{rank}) = shape({f_var})'
f_native_*_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - '{f_type}, allocatable :: {f_var}{f_assumed_shape}'
  c_helper: copy_array
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_array_{cxx_type}
  name: f_native_*_result_buf_allocatable
  ntemps: 1
  post_call:
  - allocate({f_var}({f_array_allocate}))
  - "call {hnamefunc0}(\t{temp0},\t {f_var},\t size({f_var},\t kind=C_SIZE_T))"
f_native_*_result_buf_pointer:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_module:
    iso_c_binding:
    - c_f_pointer
  name: f_native_*_result_buf_pointer
  ntemps: 1
  post_call:
  - call c_f_pointer({temp0}%base_addr, {F_result}{f_array_shape})
f_native_*_result_buf_pointer_caller:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  - 'type({F_capsule_type}), intent(OUT) :: {c_var_capsule}'
  arg_name:
  - '{c_var_capsule}'
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: capsule_helper
  f_module:
    iso_c_binding:
    - c_f_pointer
  name: f_native_*_result_buf_pointer_caller
  ntemps: 1
  post_call:
  - "call c_f_pointer(\t{temp0}%base_addr,\t {F_result}{f_array_shape})"
  - '{c_var_capsule}%mem = {temp0}%cxx'
f_native_*_result_pointer:
  call:
  - '{F_pointer} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_pointer}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  name: f_native_*_result_pointer
  post_call:
  - call c_f_pointer({F_pointer}, {F_result}{f_array_shape})
f_native_*_result_raw:
  arg_decl:
  - 'type(C_PTR) :: {f_var}'
  name: f_native_*_result_raw
f_native_*_result_scalar:
  name: f_native_*_result_scalar
f_shadow_ctor:
  call:
  - '{F_result_ptr} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_result_ptr}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_shadow_ctor
  need_wrapper: true
f_shadow_result:
  call:
  - '{F_result_ptr} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_result_ptr}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_shadow_result
  need_wrapper: true
f_string_&_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  c_helper: copy_string
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_string array_context
  name: f_string_&_result_buf_allocatable
  need_wrapper: true
  ntemps: 1
  post_call:
  - 'allocate(character(len={temp0}%elem_len):: {f_var})'
  - "call {hnamefunc0}({temp0},\t {f_var},\t {temp0}%elem_len)"
f_string_&_result_cfi_allocatable:
  arg_c_call:
  - '{f_var}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  name: f_string_&_result_cfi_allocatable
  need_wrapper: true
f_string_*_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  c_helper: copy_string
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_string array_context
  name: f_string_*_result_buf_allocatable
  need_wrapper: true
  ntemps: 1
  post_call:
  - 'allocate(character(len={temp0}%elem_len):: {f_var})'
  - "call {hnamefunc0}({temp0},\t {f_var},\t {temp0}%elem_len)"
f_string_*_result_cfi_allocatable:
  arg_c_call:
  - '{f_var}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  name: f_string_*_result_cfi_allocatable
  need_wrapper: true
f_string_scalar_in:
  arg_decl:
  - 'character(len=*), intent(IN) :: {f_var}'
  name: f_string_scalar_in
  need_wrapper: true
f_string_scalar_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  c_helper: copy_string
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_string array_context
  name: f_string_scalar_result_buf_allocatable
  need_wrapper: true
  ntemps: 1
  post_call:
  - 'allocate(character(len={temp0}%elem_len):: {f_var})'
  - "call {hnamefunc0}({temp0},\t {f_var},\t {temp0}%elem_len)"
f_string_scalar_result_cfi_allocatable:
  arg_c_call:
  - '{f_var}'
  arg_decl:
  - 'character(len=:), allocatable :: {f_var}'
  name: f_string_scalar_result_cfi_allocatable
  need_wrapper: true
f_struct_*_result:
  call:
  - '{F_pointer} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_pointer}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  name: f_struct_*_result
  post_call:
  - call c_f_pointer({F_pointer}, {F_result}{f_array_shape})
f_struct_*_result_buf_pointer:
  arg_decl:
  - '{f_type}, pointer :: {f_var}{f_assumed_shape}'
  call:
  - '{F_pointer} = {F_C_call}({F_arg_c_call})'
  declare:
  - 'type(C_PTR) :: {F_pointer}'
  f_module:
    iso_c_binding:
    - C_PTR
    - c_f_pointer
  name: f_struct_*_result_buf_pointer
  post_call:
  - call c_f_pointer({F_pointer}, {F_result}{f_array_shape})
f_struct_scalar_result:
  name: f_struct_scalar_result
f_vector_inout:
  c_helper: copy_array
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_inout
  post_call:
  - "call {hnamefunc0}(\t{c_var_context},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_vector_inout_allocatable:
  c_helper: copy_array
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_inout_allocatable
  post_call:
  - if (allocated({f_var})) deallocate({f_var})
  - allocate({f_var}({c_var_context}%size))
  - "call {hnamefunc0}(\t{c_var_context},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_vector_out:
  c_helper: copy_array
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_out
  post_call:
  - "call {hnamefunc0}(\t{c_var_context},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_vector_out_allocatable:
  c_helper: copy_array
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_out_allocatable
  post_call:
  - allocate({f_var}({c_var_context}%size))
  - "call {hnamefunc0}(\t{c_var_context},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_vector_result:
  c_helper: copy_array
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_result
  post_call:
  - "call {hnamefunc0}(\t{c_var_context},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_vector_result_buf_allocatable:
  arg_c_call:
  - '{temp0}'
  arg_decl:
  - '{f_type}, allocatable :: {f_var}{f_assumed_shape}'
  c_helper: copy_array
  declare:
  - 'type({F_array_type}) :: {temp0}'
  f_helper: copy_array_{cxx_T}
  f_module:
    iso_c_binding:
    - C_SIZE_T
  name: f_vector_result_buf_allocatable
  ntemps: 1
  post_call:
  - allocate({f_var}({temp0}%size))
  - "call {hnamefunc0}(\t{temp0},\t {f_var},\t size({f_var},kind=C_SIZE_T))"
f_void_**_in:
  arg_decl:
  - 'type(C_PTR), intent(IN) :: {f_var}{f_assumed_shape}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_void_**_in
f_void_**_out:
  arg_decl:
  - 'type(C_PTR), intent(OUT) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_void_**_out
f_void_*_cdesc:
  arg_decl:
  - '{f_type}, intent({f_intent}), target :: {f_var}{f_assumed_shape}'
  f_helper: ShroudTypeDefines
  f_module:
    iso_c_binding:
    - C_LOC
  name: f_void_*_cdesc
  pre_call:
  - '{c_var_context}%base_addr = C_LOC({f_var})'
  - '{c_var_context}%type = {sh_type}'
  - '! {c_var_context}%elem_len = C_SIZEOF()'
  - '{c_var_context}%size = {size}'
  - '{c_var_context}%rank = {rank}'
  - '{c_var_context}%shape(1:{rank}) = shape({f_var})'
f_void_*_in:
  arg_decl:
  - 'type(C_PTR), intent(IN) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_void_*_in
f_void_*_result:
  arg_decl:
  - 'type(C_PTR) :: {f_var}'
  f_module:
    iso_c_binding:
    - C_PTR
  name: f_void_*_result
***** Python
root
  base
    py
      ctor
        array -- base_py_ctor_array
          fill -- base_py_ctor_array_fill
  py
    bool
      *
        inout -- py_bool_*_inout
        out -- py_bool_*_out
      in -- py_bool_in
      inout -- py_bool_inout
      out -- py_bool_out
      result -- py_bool_result
    char
      *
        in -- py_char_*_in
        inout -- py_char_*_inout
        out
          charlen -- py_char_*_out_charlen
        result -- py_char_*_result
      **
        in -- py_char_**_in
      scalar
        in -- py_char_scalar_in
        result -- py_char_scalar_result
    ctor
      char
        * -- py_ctor_char_*
        ** -- py_ctor_char_**
        [] -- py_ctor_char_[]
      native -- py_ctor_native
        * -- py_ctor_native_*
        [] -- py_ctor_native_[]
    descr
      char
        * -- py_descr_char_*
        **
          list -- py_descr_char_**_list
        [] -- py_descr_char_[]
      native -- py_descr_native
        *
          list -- py_descr_native_*_list
          numpy -- py_descr_native_*_numpy
        []
          list -- py_descr_native_[]_list
          numpy -- py_descr_native_[]_numpy
    native
      &
        in -- py_native_&_in
        inout -- py_native_&_inout
        out -- py_native_&_out
        result
          pointer
            numpy -- py_native_&_result_pointer_numpy
      *
        in -- py_native_*_in
          pointer
            list -- py_native_*_in_pointer_list
            numpy -- py_native_*_in_pointer_numpy
        inout -- py_native_*_inout
          pointer
            list -- py_native_*_inout_pointer_list
            numpy -- py_native_*_inout_pointer_numpy
        out -- py_native_*_out
          allocatable
            list -- py_native_*_out_allocatable_list
            numpy -- py_native_*_out_allocatable_numpy
          pointer
            list -- py_native_*_out_pointer_list
            numpy -- py_native_*_out_pointer_numpy
        result
          allocatable
            numpy -- py_native_*_result_allocatable_numpy
          pointer
            list -- py_native_*_result_pointer_list
            numpy -- py_native_*_result_pointer_numpy
      *&
        out
          pointer
            numpy -- py_native_*&_out_pointer_numpy
      **
        out
          pointer
            list -- py_native_**_out_pointer_list
            numpy -- py_native_**_out_pointer_numpy
          raw -- py_native_**_out_raw
    shadow
      &
        in -- py_shadow_&_in
        result -- py_shadow_&_result
      *
        in -- py_shadow_*_in
        inout -- py_shadow_*_inout
        out -- py_shadow_*_out
        result -- py_shadow_*_result
      scalar
        in -- py_shadow_scalar_in
    string
      &
        in -- py_string_&_in
        inout -- py_string_&_inout
        out -- py_string_&_out
        result -- py_string_&_result
      *
        in -- py_string_*_in
        inout -- py_string_*_inout
        out -- py_string_*_out
        result -- py_string_*_result
      scalar
        in -- py_string_scalar_in
        inout -- py_string_scalar_inout
        out -- py_string_scalar_out
        result -- py_string_scalar_result
    struct
      &
        in
          class -- py_struct_&_in_class
          numpy -- py_struct_&_in_numpy
        inout
          class -- py_struct_&_inout_class
          numpy -- py_struct_&_inout_numpy
        out
          class -- py_struct_&_out_class
          numpy -- py_struct_&_out_numpy
      *
        in
          class -- py_struct_*_in_class
          list -- py_struct_*_in_list
          numpy -- py_struct_*_in_numpy
        inout
          class -- py_struct_*_inout_class
          list -- py_struct_*_inout_list
          numpy -- py_struct_*_inout_numpy
        out
          class -- py_struct_*_out_class
          list -- py_struct_*_out_list
          numpy -- py_struct_*_out_numpy
      in
        list -- py_struct_in_list
      inout
        list -- py_struct_inout_list
      out
        list -- py_struct_out_list
      result
        class -- py_struct_result_class
        numpy -- py_struct_result_numpy
      scalar
        in
          class -- py_struct_scalar_in_class
          list -- py_struct_scalar_in_list
          numpy -- py_struct_scalar_in_numpy
    vector
      in
        list -- py_vector_in_list
        numpy -- py_vector_in_numpy
      out
        list -- py_vector_out_list
        numpy -- py_vector_out_numpy
      result
        list -- py_vector_result_list
        numpy -- py_vector_result_numpy
    void
      *
        in -- py_void_*_in
        result -- py_void_*_result
      *&
        out -- py_void_*&_out
      **
        out -- py_void_**_out
base_py_ctor_array:
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  name: base_py_ctor_array
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
base_py_ctor_array_fill:
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  name: base_py_ctor_array_fill
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_bool_*_inout:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - bool {cxx_var};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_bool_*_inout
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_bool_*_out:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - bool {cxx_var};
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_bool_*_out
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_bool_in:
  name: py_bool_in
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_bool_inout:
  arg_declare:
  - bool {cxx_var};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_bool_inout
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = PyObject_IsTrue({py_var});'
py_bool_out:
  arg_declare:
  - bool {cxx_var};
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_bool_out
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_bool_result:
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_bool_result
  object_created: true
  post_call:
  - '{py_var} = PyBool_FromLong({c_var});'
  - if ({py_var} == {nullptr}) goto fail;
py_char_**_in:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{c_const}char ** {cxx_var} = {nullptr};'
  c_helper: get_from_object_charptr
  declare:
  - PyObject * {pytmp_var};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  name: py_char_**_in
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_call:
  - Py_XDECREF({value_var}.dataobj);
  pre_call:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}char **{cast1}{value_var}.data{cast2};'
py_char_*_in:
  arg_call:
  - '{c_var}'
  name: py_char_*_in
py_char_*_inout:
  arg_call:
  - '{c_var}'
  fmtdict:
    ctor_expr: '{c_var}'
  name: py_char_*_inout
py_char_*_out_charlen:
  arg_call:
  - '{c_var}'
  arg_declare:
  - '{c_const}char {c_var}[{charlen}];  // intent(out)'
  fmtdict:
    ctor_expr: '{c_var}'
  name: py_char_*_out_charlen
py_char_*_result:
  fmtdict:
    ctor_expr: '{c_var}'
  name: py_char_*_result
py_char_scalar_in:
  arg_call:
  - '{c_var}[0]'
  arg_declare:
  - char *{c_var};
  name: py_char_scalar_in
  parse_args:
  - '&{c_var}'
  parse_format: s
py_char_scalar_result:
  declare:
  - '{PyObject} * {py_var} = {nullptr};'
  name: py_char_scalar_result
  object_created: true
  post_call:
  - '{py_var} = PyString_FromStringAndSize(&{cxx_var}, 1);'
py_ctor_char_*:
  c_helper: get_from_object_char
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  name: py_ctor_char_*
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_**:
  c_helper: get_from_object_charptr
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  name: py_ctor_char_**
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}char **{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_char_[]:
  c_helper: fill_from_PyObject_char
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  name: py_ctor_char_[]
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_ctor_native:
  declare:
  - '{c_type} {c_var} = 0;'
  name: py_ctor_native
  post_call:
  - SH_obj->{field_name} = {field_name};
py_ctor_native_*:
  c_helper: get_from_object_{c_type}_{PY_array_arg}
  declare:
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{field_name}";'
  name: py_ctor_native_*
  parse_args:
  - '{hnamefunc0}'
  - '&{value_var}'
  parse_format: O&
  post_call:
  - SH_obj->{field_name} = {cast_static}{c_type} *{cast1}{value_var}.data{cast2};
  - self->{PY_member_object} = {value_var}.obj;  // steal reference
py_ctor_native_[]:
  c_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
  declare:
  - PyObject *{py_var} = {nullptr};
  goto_fail: true
  name: py_ctor_native_[]
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_call:
  - if ({py_var} != {nullptr}) {{+
  - "if ({hnamefunc0}(\t{py_var},\t \"{c_var}\",\t SH_obj->{field_name},\t {field_size})\
    \ == -1)"
  - +goto fail;-
  - self->{PY_member_object} = {nullptr};
  - -}}
py_descr_char_*:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - PyObject * rv = {ctor};
  - return rv;
  name: py_descr_char_*
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_data});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_data} = {nullptr};'
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_data} = cvalue.dataobj;  // steal reference'
  setter_helper: get_from_object_{c_type}_list
py_descr_char_**_list:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_char
  name: py_descr_char_**_list
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_data});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_data} = {nullptr};'
  - // XXXX set error
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_data} = cvalue.dataobj;  // steal reference'
  setter_helper: get_from_object_charptr
py_descr_char_[]:
  getter:
  - 'if ({c_var_obj} != {nullptr}) {{+

    Py_INCREF({c_var_obj});

    return {c_var_obj};

    -}}

    PyObject * rv = PyString_FromString({c_var});

    // XXX assumes is null terminated

    return rv;'
  name: py_descr_char_[]
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_char
py_descr_native:
  getter:
  - PyObject * rv = {ctor};
  - return rv;
  name: py_descr_native
  setter:
  - '{cxx_decl} = {PY_get};'
  - if (PyErr_Occurred()) {{+
  - return -1;
  - -}}
  - '{c_var} = rv;'
py_descr_native_*_list:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - if ({c_var_obj} != {nullptr}) {{+
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  - -}}
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_{c_type}
  name: py_descr_native_*_list
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_obj});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_obj} = {nullptr};'
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_obj} = cvalue.obj;  // steal reference'
  setter_helper: get_from_object_{c_type}_list
py_descr_native_*_numpy:
  getter:
  - if ({c_var} == {nullptr}) {{+
  - Py_RETURN_NONE;
  - -}}
  - if ({c_var_obj} != {nullptr}) {{+
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  - -}}
  - npy_intp {npy_dims_var}[{npy_rank}] = {{ {npy_intp_values} }};
  - "PyObject *rv = PyArray_SimpleNewFromData(\t{npy_rank},\t {npy_dims_var},\t {PYN_typenum},\t\
    \ {c_var_non_const});"
  - if (rv != {nullptr}) {{+
  - Py_INCREF(rv);
  - '{c_var_obj} = rv;'
  - -}}
  - return rv;
  name: py_descr_native_*_numpy
  need_numpy: true
  setter:
  - '{PY_typedef_converter} cvalue;'
  - Py_XDECREF({c_var_obj});
  - if ({hnamefunc0}({py_var}, &cvalue) == 0) {{+
  - '{c_var} = {nullptr};'
  - '{c_var_obj} = {nullptr};'
  - // XXXX set error
  - return -1;
  - -}}
  - '{c_var} = {cast_static}{cast_type}{cast1}cvalue.data{cast2};'
  - '{c_var_obj} = cvalue.obj;  // steal reference'
  setter_helper: get_from_object_{c_type}_numpy
py_descr_native_[]_list:
  getter:
  - PyObject *rv = {hnamefunc0}({c_var}, {npy_intp_size});
  - return rv;
  getter_helper: to_PyList_{c_type}
  name: py_descr_native_[]_list
  need_numpy: true
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
py_descr_native_[]_numpy:
  getter:
  - if ({c_var_obj} == {nullptr}) {{+
  - // Create Numpy object which points to struct member.
  - npy_intp {npy_dims_var}[{rank}] = {{ {npy_intp_values} }};
  - "{c_var_obj} = PyArray_SimpleNewFromData(\t{npy_rank},\t {npy_dims_var},\t {PYN_typenum},\t\
    \ {c_var});"
  - -}}
  - Py_INCREF({c_var_obj});
  - return {c_var_obj};
  name: py_descr_native_[]_numpy
  need_numpy: true
  setter:
  - Py_XDECREF({c_var_obj});
  - '{c_var_obj} = {nullptr};'
  - "if ({hnamefunc0}(\t{py_var},\t \"{field_name}\",\t {c_var},\t {npy_intp_size})\
    \ == -1) {{+"
  - return -1;
  - -}}
  setter_helper: fill_from_PyObject_{c_type}_{PY_array_arg}
py_native_&_in:
  arg_declare:
  - '{c_type} {c_var};'
  name: py_native_&_in
py_native_&_inout:
  arg_declare:
  - '{c_type} {c_var};'
  name: py_native_&_inout
py_native_&_out:
  arg_declare:
  - '{c_const}{c_type} {c_var};'
  name: py_native_&_out
py_native_&_result_pointer_numpy:
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_native_&_result_pointer_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_native_*&_out_pointer_numpy:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  declare:
  - '{npy_intp_decl}PyObject *{py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_native_*&_out_pointer_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_native_**_out_pointer_list:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  c_helper: to_PyList_{cxx_type}
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_**_out_pointer_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
py_native_**_out_pointer_numpy:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_const}{c_type} *{c_var};'
  declare:
  - '{npy_intp_decl}PyObject *{py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_native_**_out_pointer_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_native_**_out_raw:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - '{c_type} *{c_var};'
  declare:
  - PyObject *{py_var} = {nullptr};
  name: py_native_**_out_raw
  object_created: true
  post_call:
  - '{py_var} = PyCapsule_New({cxx_var}, NULL, NULL);'
py_native_*_in:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  name: py_native_*_in
py_native_*_in_pointer_list:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_helper: get_from_object_{cxx_type}_list
  cleanup:
  - Py_XDECREF({value_var}.dataobj);
  declare:
  - PyObject *{pytmp_var} = {nullptr};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  name: py_native_*_in_pointer_list
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}{cxx_type} *{cast1}{value_var}.data{cast2};'
  - '{size_var} = {value_var}.size;'
py_native_*_in_pointer_numpy:
  arg_call:
  - '{c_var}'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_*_in_pointer_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FROM_OTF(\t{pytmp_var},\t\
    \ {numpy_type},\t NPY_ARRAY_IN_ARRAY){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_native_*_inout:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  fmtdict:
    ctor_expr: '{c_var}'
  name: py_native_*_inout
py_native_*_inout_pointer_list:
  arg_call:
  - '{cxx_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_helper: get_from_object_{cxx_type}_list to_PyList_{cxx_type}
  cleanup:
  - Py_XDECREF({value_var}.dataobj);
  declare:
  - PyObject *{py_var};
  - PyObject *{pytmp_var} = {nullptr};
  - '{PY_typedef_converter} {value_var} = {PY_value_init};'
  - '{value_var}.name = "{c_var}";'
  - Py_ssize_t {size_var};
  fail:
  - Py_XDECREF({value_var}.dataobj);
  goto_fail: true
  name: py_native_*_inout_pointer_list
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_call:
  - "{py_var} = {hnamefunc1}\t({cxx_var},\t {size_var});"
  - if ({py_var} == {nullptr}) goto fail;
  post_parse:
  - "if ({hnamefunc0}\t({pytmp_var}, &{value_var}) == 0)"
  - +goto fail;-
  - '{cxx_var} = {cast_static}{cxx_type} *{cast1}{value_var}.data{cast2};'
  - '{size_var} = {value_var}.size;'
py_native_*_inout_pointer_numpy:
  arg_call:
  - '{c_var}'
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_*_inout_pointer_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FROM_OTF(\t{pytmp_var},\t\
    \ {numpy_type},\t NPY_ARRAY_INOUT_ARRAY){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_native_*_out:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - '{c_type} {c_var};'
  fmtdict:
    ctor_expr: '{c_var}'
  name: py_native_*_out
py_native_*_out_allocatable_list:
  arg_call:
  - '{c_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_header:
  - <stdlib.h>
  c_helper: to_PyList_{cxx_type}
  cleanup:
  - '{stdlib}free({cxx_var});'
  - '{cxx_var} = {nullptr};'
  cxx_header:
  - <cstdlib>
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  - "if ({cxx_var} != {nullptr})\t {stdlib}free({cxx_var});"
  goto_fail: true
  name: py_native_*_out_allocatable_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(std::malloc(\tsizeof({cxx_type}) * ({array_size})));"
  - if ({cxx_var} == {nullptr}) {{+
  - PyErr_NoMemory();
  - goto fail;
  - -}}
py_native_*_out_allocatable_numpy:
  arg_call:
  - '{c_var}'
  declare:
  - '{npy_intp_decl}PyArrayObject * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_*_out_allocatable_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - '{npy_intp_asgn}{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_SimpleNew({npy_rank},
    {npy_dims_var}, {numpy_type}){cast2};'
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_native_*_out_pointer_list:
  arg_call:
  - '{c_var}'
  arg_declare:
  - '{cxx_type} * {cxx_var} = {nullptr};'
  c_header:
  - <stdlib.h>
  c_helper: to_PyList_{cxx_type}
  cleanup:
  - '{stdlib}free({cxx_var});'
  - '{cxx_var} = {nullptr};'
  cxx_header:
  - <cstdlib>
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  - "if ({cxx_var} != {nullptr})\t {stdlib}free({cxx_var});"
  goto_fail: true
  name: py_native_*_out_pointer_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(std::malloc(\tsizeof({cxx_type}) * ({array_size})));"
  - if ({cxx_var} == {nullptr}) {{+
  - PyErr_NoMemory();
  - goto fail;
  - -}}
py_native_*_out_pointer_numpy:
  arg_call:
  - '{c_var}'
  declare:
  - '{npy_intp_decl}PyArrayObject * {py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_*_out_pointer_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - '{npy_intp_asgn}{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_SimpleNew({npy_rank},
    {npy_dims_var}, {numpy_type}){cast2};'
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_native_*_result_allocatable_numpy:
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_native_*_result_allocatable_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_native_*_result_pointer_list:
  c_helper: to_PyList_{cxx_type}
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_native_*_result_pointer_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var},\t {array_size});"
  - if ({py_var} == {nullptr}) goto fail;
py_native_*_result_pointer_numpy:
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_native_*_result_pointer_numpy
  need_numpy: true
  object_created: true
  post_call:
  - "{npy_intp_asgn}{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t\
    \ {numpy_type},\t {cxx_nonconst_ptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_shadow_&_in:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  name: py_shadow_&_in
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_shadow_&_result:
  name: py_shadow_&_result
  object_created: true
  post_call:
  - "{PyObject} * {py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_shadow_*_in:
  cxx_local_var: pointer
  name: py_shadow_*_in
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_shadow_*_inout:
  cxx_local_var: pointer
  name: py_shadow_*_inout
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_shadow_*_out:
  declare:
  - '{PyObject} *{py_var} = {nullptr};'
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_shadow_*_out
  object_created: true
  post_call:
  - "{py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - if ({py_var} == {nullptr}) goto fail;
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_shadow_*_result:
  name: py_shadow_*_result
  object_created: true
  post_call:
  - "{PyObject} * {py_var} =\t PyObject_New({PyObject}, &{PyTypeObject});"
  - '{py_var}->{PY_type_obj} = {cxx_addr}{cxx_var};'
py_shadow_scalar_in:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  name: py_shadow_scalar_in
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_string_&_in:
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_&_in
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_&_inout:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_&_inout
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_&_out:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_&_out
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_string_&_result:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_&_result
py_string_*_in:
  arg_call:
  - '&{cxx_var}'
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_*_in
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_*_inout:
  arg_call:
  - '&{cxx_var}'
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_*_inout
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_*_out:
  arg_call:
  - '&{cxx_var}'
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_*_out
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_string_*_result:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_*_result
py_string_scalar_in:
  arg_declare:
  - char * {c_var};
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_scalar_in
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_scalar_inout:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_scalar_inout
  post_declare:
  - '{c_const}std::string {cxx_var}({c_var});'
py_string_scalar_out:
  cxx_local_var: scalar
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_scalar_out
  post_declare:
  - '{c_const}std::string {cxx_var};'
py_string_scalar_result:
  fmtdict:
    ctor_expr: "{cxx_var}{cxx_member}data(),\t {cxx_var}{cxx_member}size()"
  name: py_string_scalar_result
py_struct_&_in_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  name: py_struct_&_in_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_struct_&_in_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_&_in_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_&_inout_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  name: py_struct_&_inout_class
  object_created: true
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_struct_&_inout_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_&_inout_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_&_out_class:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var} = {nullptr};'
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_&_out_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = new {cxx_type};'
py_struct_&_out_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_&_out_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_NewFromDescr(\t&PyArray_Type,\t\
    \ {PYN_descr},\t 0,\t {nullptr},\t {nullptr},\t {nullptr},\t 0,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_*_in_class:
  cxx_local_var: pointer
  name: py_struct_*_in_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_struct_*_in_list:
  arg_call:
  - '&{cxx_var}'
  name: py_struct_*_in_list
py_struct_*_in_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_*_in_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_*_inout_class:
  cxx_local_var: pointer
  name: py_struct_*_inout_class
  object_created: true
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_struct_*_inout_list:
  arg_call:
  - '&{cxx_var}'
  name: py_struct_*_inout_list
py_struct_*_inout_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_*_inout_numpy
  need_numpy: true
  object_created: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_*_out_class:
  arg_declare:
  - '{cxx_type} *{cxx_var} = {nullptr};'
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_*_out_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_addr}{cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
  pre_call:
  - '{cxx_var} = new {cxx_type};'
py_struct_*_out_list:
  arg_call:
  - '&{cxx_var}'
  name: py_struct_*_out_list
  post_declare:
  - '{cxx_type} {cxx_var};'
py_struct_*_out_numpy:
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  declare:
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_*_out_numpy
  need_numpy: true
  object_created: true
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_NewFromDescr(\t&PyArray_Type,\t\
    \ {PYN_descr},\t 0,\t {nullptr},\t {nullptr},\t {nullptr},\t 0,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_struct_in_list:
  name: py_struct_in_list
py_struct_inout_list:
  name: py_struct_inout_list
py_struct_out_list:
  name: py_struct_out_list
  post_declare:
  - '{cxx_type} {cxx_var};'
py_struct_result_class:
  allocate_local_var: true
  cxx_local_var: pointer
  declare:
  - PyObject *{py_var} = {nullptr};  // struct_result_class
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_result_class
  object_created: true
  post_call:
  - "{py_var} = {PY_to_object_idtor_func}({cxx_addr}{cxx_var},\t {capsule_order});"
  - if ({py_var} == {nullptr}) goto fail;
py_struct_result_numpy:
  allocate_local_var: true
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_struct_result_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_intp_asgn}Py_INCREF({PYN_descr});'
  - "{py_var} = PyArray_NewFromDescr(&PyArray_Type, \t{PYN_descr},\t {npy_rank}, {npy_dims_var},\
    \ \t{nullptr}, {cxx_var}, 0, {nullptr});"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_struct_scalar_in_class:
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  name: py_struct_scalar_in_class
  post_declare:
  - "{c_const}{cxx_type} * {cxx_var} =\t {py_var} ? {py_var}->{PY_type_obj} : {nullptr};"
py_struct_scalar_in_list:
  name: py_struct_scalar_in_list
py_struct_scalar_in_numpy:
  arg_call:
  - '*{cxx_var}'
  arg_declare:
  - '{cxx_type} *{cxx_var};'
  cleanup:
  - '{PY_cleanup_decref}({py_var});'
  cxx_local_var: pointer
  declare:
  - PyObject * {pytmp_var} = {nullptr};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_struct_scalar_in_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_parse:
  - Py_INCREF({PYN_descr});
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FromAny(\t{pytmp_var},\t\
    \ {PYN_descr},\t 0,\t 1,\t NPY_ARRAY_IN_ARRAY,\t {nullptr}){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {c_type}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - "{cxx_var} = static_cast<{cxx_type} *>\t(PyArray_DATA({py_var}));"
py_vector_in_list:
  c_helper: create_from_PyObject_vector_{cxx_T}
  cxx_local_var: scalar
  declare:
  - PyObject * {pytmp_var};
  goto_fail: true
  name: py_vector_in_list
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
  pre_call:
  - "if ({hnamefunc0}\t({pytmp_var},\t \"{c_var}\",\t {cxx_var}) == -1)"
  - +goto fail;-
py_vector_in_numpy:
  cxx_local_var: scalar
  declare:
  - PyObject * {pytmp_var};
  - PyArrayObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_vector_in_numpy
  need_numpy: true
  parse_args:
  - '&{pytmp_var}'
  parse_format: O
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
  - '{cxx_T} * {data_var};'
  post_parse:
  - "{py_var} = {cast_reinterpret}PyArrayObject *{cast1}PyArray_FROM_OTF(\t{pytmp_var},\t\
    \ {numpy_type},\t NPY_ARRAY_IN_ARRAY){cast2};"
  - if ({py_var} == {nullptr}) {{+
  - "PyErr_SetString(PyExc_ValueError,\t \"{c_var} must be a 1-D array of {cxx_T}\"\
    );"
  - goto fail;
  - -}}
  pre_call:
  - '{data_var} = static_cast<{cxx_T} *>(PyArray_DATA({py_var}));'
  - "{cxx_var}.assign(\t{data_var},\t {data_var}+PyArray_SIZE({py_var}));"
py_vector_out_list:
  c_helper: to_PyList_vector_{cxx_T}
  cxx_local_var: scalar
  declare:
  - PyObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_vector_out_list
  object_created: true
  post_call:
  - "{py_var} = {hnamefunc0}\t({cxx_var});"
  - if ({py_var} == {nullptr}) goto fail;
  post_declare:
  - std::vector<{cxx_T}> {cxx_var};
py_vector_out_numpy:
  allocate_local_var: true
  arg_call:
  - '*{cxx_var}'
  cxx_local_var: pointer
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_vector_out_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_dims_var}[0] = {cxx_var}->size();'
  - "{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t {numpy_type},\t\
    \ {cxx_var}->data());"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_vector_result_list:
  declare:
  - PyObject * {py_var} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  goto_fail: true
  name: py_vector_result_list
  object_created: true
  post_call:
  - "{py_var} = SHROUD_to_PyList_vector_{cxx_T}\t({cxx_var});"
  - if ({py_var} == {nullptr}) goto fail;
py_vector_result_numpy:
  allocate_local_var: true
  declare:
  - '{npy_intp_decl}PyObject * {py_var} = {nullptr};'
  declare_capsule:
  - PyObject *{py_capsule} = {nullptr};
  fail:
  - Py_XDECREF({py_var});
  fail_capsule:
  - Py_XDECREF({py_capsule});
  goto_fail: true
  name: py_vector_result_numpy
  need_numpy: true
  object_created: true
  post_call:
  - '{npy_dims_var}[0] = {cxx_var}->size();'
  - "{py_var} = PyArray_SimpleNewFromData({npy_rank},\t {npy_dims_var},\t {numpy_type},\t\
    \ {cxx_var}->data());"
  - if ({py_var} == {nullptr}) goto fail;
  post_call_capsule:
  - "{py_capsule} = PyCapsule_New({cxx_var}, \"{PY_numpy_array_capsule_name}\", \t\
    {PY_capsule_destructor_function});"
  - if ({py_capsule} == {nullptr}) goto fail;
  - "PyCapsule_SetContext({py_capsule},\t {PY_fetch_context_function}({capsule_order}));"
  - "if (PyArray_SetBaseObject(\t{cast_reinterpret}PyArrayObject *{cast1}{py_var}{cast2},\t\
    \ {py_capsule}) < 0)\t goto fail;"
py_void_*&_out:
  arg_call:
  - '{c_var}'
  arg_declare:
  - void *{c_var};
  fmtdict:
    ctor_expr: '{cxx_var}'
  name: py_void_*&_out
py_void_**_out:
  arg_call:
  - '&{c_var}'
  arg_declare:
  - void *{c_var};
  fmtdict:
    ctor_expr: '{cxx_var}'
  name: py_void_**_out
py_void_*_in:
  arg_call:
  - '{c_var}'
  declare:
  - PyObject *{py_var};
  goto_fail: true
  name: py_void_*_in
  parse_args:
  - '&{py_var}'
  parse_format: O
  post_parse:
  - '{c_var} = PyCapsule_GetPointer({py_var}, NULL);'
  - if (PyErr_Occurred())
  - +goto fail;-
py_void_*_result:
  fmtdict:
    ctor_expr: '{cxx_var}'
  name: py_void_*_result
***** Lua
root
  lua
    bool
      scalar
        in -- lua_bool_scalar_in
        result -- lua_bool_scalar_result
    mixin
      callfunction -- lua_mixin_callfunction
      push -- lua_mixin_push
    native
      *
        inout -- lua_native_*_inout
      scalar
        in -- lua_native_scalar_in
        result -- lua_native_scalar_result
    shadow
      *
        in -- lua_shadow_*_in
        result -- lua_shadow_*_result
      ctor -- lua_shadow_ctor
      dtor -- lua_shadow_dtor
    string
      &
        in -- lua_string_&_in
        result -- lua_string_&_result
      *
        in -- lua_string_*_in
      scalar
        result -- lua_string_scalar_result
    subroutine -- lua_subroutine
    void
      *
        result -- lua_void_*_result
lua_bool_scalar_in:
  name: lua_bool_scalar_in
  pre_call:
  - bool {c_var} = {pop_expr};
lua_bool_scalar_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_bool_scalar_result
  post_call:
  - '{push_expr};'
lua_mixin_callfunction:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_mixin_callfunction
lua_mixin_push:
  name: lua_mixin_push
  post_call:
  - '{push_expr};'
lua_native_*_inout:
  name: lua_native_*_inout
  pre_call:
  - // lua_native_*_inout;
lua_native_scalar_in:
  name: lua_native_scalar_in
  pre_call:
  - "{cxx_type} {cxx_var} =\t {pop_expr};"
lua_native_scalar_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_native_scalar_result
  post_call:
  - '{push_expr};'
lua_shadow_*_in:
  name: lua_shadow_*_in
  pre_call:
  - "{cxx_type} * {cxx_var} =\t {pop_expr};"
lua_shadow_*_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_shadow_*_result
  post_call:
  - '{push_expr};'
lua_shadow_ctor:
  call:
  - "{LUA_userdata_type} * {LUA_userdata_var} =\t ({LUA_userdata_type} *) lua_newuserdata({LUA_state_var},\
    \ sizeof(*{LUA_userdata_var}));"
  - "{LUA_userdata_var}->{LUA_userdata_member} =\t new {namespace_scope}{cxx_class}({cxx_call_list});"
  - /* Add the metatable to the stack. */
  - luaL_getmetatable(L, "{LUA_metadata}");
  - /* Set the metatable on the userdata. */
  - lua_setmetatable(L, -2);
  name: lua_shadow_ctor
lua_shadow_dtor:
  call:
  - delete {LUA_userdata_var}->{LUA_userdata_member};
  - '{LUA_userdata_var}->{LUA_userdata_member} = NULL;'
  name: lua_shadow_dtor
lua_string_&_in:
  name: lua_string_&_in
  pre_call:
  - "const char * {c_var} = \t{pop_expr};"
lua_string_&_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_string_&_result
  post_call:
  - '{push_expr};'
lua_string_*_in:
  name: lua_string_*_in
  pre_call:
  - "const char * {c_var} = \t{pop_expr};"
lua_string_scalar_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_string_scalar_result
  post_call:
  - '{push_expr};'
lua_subroutine:
  call:
  - '{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_subroutine
lua_void_*_result:
  call:
  - '{rv_asgn}{LUA_this_call}{function_name}({cxx_call_list});'
  name: lua_void_*_result
