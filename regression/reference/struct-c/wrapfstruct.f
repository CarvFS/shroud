! wrapfstruct.f
! This file is generated by Shroud nowrite-version. Do not edit.
! Copyright (c) 2017-2021, Lawrence Livermore National Security, LLC and
! other Shroud Project Developers.
! See the top-level COPYRIGHT file for details.
!
! SPDX-License-Identifier: (BSD-3-Clause)
!
!>
!! \file wrapfstruct.f
!! \brief Shroud generated wrapper for struct library
!<
! splicer begin file_top
! splicer end file_top
module struct_mod
    use iso_c_binding, only : C_CHAR, C_DOUBLE, C_INT, C_NULL_PTR, C_PTR
    ! splicer begin module_use
    ! splicer end module_use
    implicit none

    ! splicer begin module_top
    integer, parameter :: MAXNAME = 20
    ! splicer end module_top

    ! start helper capsule_data_helper
    ! helper capsule_data_helper
    type, bind(C) :: STR_SHROUD_capsule_data
        type(C_PTR) :: addr = C_NULL_PTR  ! address of C++ memory
        integer(C_INT) :: idtor = 0       ! index of destructor
    end type STR_SHROUD_capsule_data
    ! end helper capsule_data_helper


    ! start derived-type cstruct1
    type, bind(C) :: cstruct1
        integer(C_INT) :: ifield
        real(C_DOUBLE) :: dfield
    end type cstruct1
    ! end derived-type cstruct1


    type, bind(C) :: cstruct_ptr
        type(C_PTR) :: cfield
        type(C_PTR) :: const_dvalue
    end type cstruct_ptr


    type, bind(C) :: cstruct_list
        integer(C_INT) :: nitems
        type(C_PTR) :: ivalue
        type(C_PTR) :: dvalue
        type(C_PTR) :: svalue
    end type cstruct_list


    type, bind(C) :: cstruct_numpy
        integer(C_INT) :: nitems
        type(C_PTR) :: ivalue
        type(C_PTR) :: dvalue
    end type cstruct_numpy


    type, bind(C) :: arrays1
        character(kind=C_CHAR) :: name(20)
        integer(C_INT) :: count(10)
    end type arrays1

    ! start derived-type cstruct_as_class
    type cstruct_as_class
        type(STR_SHROUD_capsule_data) :: cxxmem
        ! splicer begin class.Cstruct_as_class.component_part
        ! splicer end class.Cstruct_as_class.component_part
    contains
        procedure :: get_x1 => cstruct_as_class_get_x1
        procedure :: set_x1 => cstruct_as_class_set_x1
        procedure :: get_y1 => cstruct_as_class_get_y1
        procedure :: set_y1 => cstruct_as_class_set_y1
        procedure :: sum => cstruct_as_class_sum
        ! splicer begin class.Cstruct_as_class.type_bound_procedure_part
        ! splicer end class.Cstruct_as_class.type_bound_procedure_part
    end type cstruct_as_class
    ! end derived-type cstruct_as_class

    ! start derived-type cstruct_as_subclass
    type, extends(cstruct_as_class) :: cstruct_as_subclass
        ! splicer begin class.Cstruct_as_subclass.component_part
        ! splicer end class.Cstruct_as_subclass.component_part
    contains
        procedure :: get_x1 => cstruct_as_subclass_get_x1
        procedure :: set_x1 => cstruct_as_subclass_set_x1
        procedure :: get_y1 => cstruct_as_subclass_get_y1
        procedure :: set_y1 => cstruct_as_subclass_set_y1
        procedure :: get_z1 => cstruct_as_subclass_get_z1
        procedure :: set_z1 => cstruct_as_subclass_set_z1
        ! splicer begin class.Cstruct_as_subclass.type_bound_procedure_part
        ! splicer end class.Cstruct_as_subclass.type_bound_procedure_part
    end type cstruct_as_subclass
    ! end derived-type cstruct_as_subclass

    interface operator (.eq.)
        module procedure cstruct_as_class_eq
        module procedure cstruct_as_subclass_eq
    end interface

    interface operator (.ne.)
        module procedure cstruct_as_class_ne
        module procedure cstruct_as_subclass_ne
    end interface

    ! ----------------------------------------
    ! Function:  int getX1
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_cstruct_as_class_get_x1
    interface
        function c_cstruct_as_class_get_x1(self) &
                result(SHT_rv) &
                bind(C, name="STR_Cstruct_as_class_get_x1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_class_get_x1
    end interface
    ! end c_cstruct_as_class_get_x1

    ! ----------------------------------------
    ! Function:  void setX1
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_cstruct_as_class_set_x1
    interface
        subroutine c_cstruct_as_class_set_x1(self, val) &
                bind(C, name="STR_Cstruct_as_class_set_x1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_cstruct_as_class_set_x1
    end interface
    ! end c_cstruct_as_class_set_x1

    ! ----------------------------------------
    ! Function:  int getY1
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_cstruct_as_class_get_y1
    interface
        function c_cstruct_as_class_get_y1(self) &
                result(SHT_rv) &
                bind(C, name="STR_Cstruct_as_class_get_y1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_class_get_y1
    end interface
    ! end c_cstruct_as_class_get_y1

    ! ----------------------------------------
    ! Function:  void setY1
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_cstruct_as_class_set_y1
    interface
        subroutine c_cstruct_as_class_set_y1(self, val) &
                bind(C, name="STR_Cstruct_as_class_set_y1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_cstruct_as_class_set_y1
    end interface
    ! end c_cstruct_as_class_set_y1

    ! splicer begin class.Cstruct_as_class.additional_interfaces
    ! splicer end class.Cstruct_as_class.additional_interfaces

    ! ----------------------------------------
    ! Function:  int getX1
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_cstruct_as_subclass_get_x1
    interface
        function c_cstruct_as_subclass_get_x1(self) &
                result(SHT_rv) &
                bind(C, name="STR_Cstruct_as_subclass_get_x1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_subclass_get_x1
    end interface
    ! end c_cstruct_as_subclass_get_x1

    ! ----------------------------------------
    ! Function:  void setX1
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_cstruct_as_subclass_set_x1
    interface
        subroutine c_cstruct_as_subclass_set_x1(self, val) &
                bind(C, name="STR_Cstruct_as_subclass_set_x1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_cstruct_as_subclass_set_x1
    end interface
    ! end c_cstruct_as_subclass_set_x1

    ! ----------------------------------------
    ! Function:  int getY1
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_cstruct_as_subclass_get_y1
    interface
        function c_cstruct_as_subclass_get_y1(self) &
                result(SHT_rv) &
                bind(C, name="STR_Cstruct_as_subclass_get_y1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_subclass_get_y1
    end interface
    ! end c_cstruct_as_subclass_get_y1

    ! ----------------------------------------
    ! Function:  void setY1
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_cstruct_as_subclass_set_y1
    interface
        subroutine c_cstruct_as_subclass_set_y1(self, val) &
                bind(C, name="STR_Cstruct_as_subclass_set_y1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_cstruct_as_subclass_set_y1
    end interface
    ! end c_cstruct_as_subclass_set_y1

    ! ----------------------------------------
    ! Function:  int getZ1
    ! Attrs:     +intent(getter)
    ! Exact:     c_getter_native_scalar
    ! start c_cstruct_as_subclass_get_z1
    interface
        function c_cstruct_as_subclass_get_z1(self) &
                result(SHT_rv) &
                bind(C, name="STR_Cstruct_as_subclass_get_z1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_subclass_get_z1
    end interface
    ! end c_cstruct_as_subclass_get_z1

    ! ----------------------------------------
    ! Function:  void setZ1
    ! Attrs:     +intent(setter)
    ! Requested: c_setter_void_scalar
    ! Match:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start c_cstruct_as_subclass_set_z1
    interface
        subroutine c_cstruct_as_subclass_set_z1(self, val) &
                bind(C, name="STR_Cstruct_as_subclass_set_z1")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: self
            integer(C_INT), value, intent(IN) :: val
        end subroutine c_cstruct_as_subclass_set_z1
    end interface
    ! end c_cstruct_as_subclass_set_z1

    ! splicer begin class.Cstruct_as_subclass.additional_interfaces
    ! splicer end class.Cstruct_as_subclass.additional_interfaces

    ! ----------------------------------------
    ! Function:  int passStructByValue
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  Cstruct1 arg +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_scalar
    ! Match:     c_in_struct
    ! start pass_struct_by_value
    interface
        function pass_struct_by_value(arg) &
                result(SHT_rv) &
                bind(C, name="passStructByValue")
            use iso_c_binding, only : C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), value, intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function pass_struct_by_value
    end interface
    ! end pass_struct_by_value

    ! ----------------------------------------
    ! Function:  int passStruct1
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct1 * arg
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_*
    ! Match:     c_in_struct
    ! start pass_struct1
    interface
        function pass_struct1(arg) &
                result(SHT_rv) &
                bind(C, name="passStruct1")
            use iso_c_binding, only : C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function pass_struct1
    end interface
    ! end pass_struct1

    ! ----------------------------------------
    ! Function:  int passStruct2
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct1 * s1
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_*
    ! Match:     c_in_struct
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    interface
        function c_pass_struct2(s1, outbuf) &
                result(SHT_rv) &
                bind(C, name="passStruct2")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), intent(IN) :: s1
            character(kind=C_CHAR), intent(OUT) :: outbuf(*)
            integer(C_INT) :: SHT_rv
        end function c_pass_struct2
    end interface

    ! ----------------------------------------
    ! Function:  int passStruct2
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct1 * s1
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_*
    ! Match:     c_in_struct
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    interface
        function c_pass_struct2_bufferify(s1, outbuf, SHT_outbuf_len) &
                result(SHT_rv) &
                bind(C, name="STR_pass_struct2_bufferify")
            use iso_c_binding, only : C_CHAR, C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), intent(IN) :: s1
            character(kind=C_CHAR), intent(OUT) :: outbuf(*)
            integer(C_INT), value, intent(IN) :: SHT_outbuf_len
            integer(C_INT) :: SHT_rv
        end function c_pass_struct2_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  int acceptStructInPtr
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  Cstruct1 * arg +intent(in)
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_*
    ! Match:     c_in_struct
    interface
        function accept_struct_in_ptr(arg) &
                result(SHT_rv) &
                bind(C, name="acceptStructInPtr")
            use iso_c_binding, only : C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), intent(IN) :: arg
            integer(C_INT) :: SHT_rv
        end function accept_struct_in_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStructOutPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  Cstruct1 * arg +intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_struct_*
    ! Match:     c_out_struct
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        subroutine accept_struct_out_ptr(arg, i, d) &
                bind(C, name="acceptStructOutPtr")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: cstruct1
            implicit none
            type(cstruct1), intent(OUT) :: arg
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
        end subroutine accept_struct_out_ptr
    end interface

    ! ----------------------------------------
    ! Function:  void acceptStructInOutPtr
    ! Attrs:     +intent(subroutine)
    ! Requested: c_subroutine_void_scalar
    ! Match:     c_subroutine
    ! ----------------------------------------
    ! Argument:  Cstruct1 * arg +intent(inout)
    ! Attrs:     +intent(inout)
    ! Requested: c_inout_struct_*
    ! Match:     c_inout_struct
    interface
        subroutine accept_struct_in_out_ptr(arg) &
                bind(C, name="acceptStructInOutPtr")
            import :: cstruct1
            implicit none
            type(cstruct1), intent(INOUT) :: arg
        end subroutine accept_struct_in_out_ptr
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct1 returnStructByValue
    ! Attrs:     +intent(function)
    ! Requested: c_function_struct_scalar
    ! Match:     c_function_struct
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        function return_struct_by_value(i, d) &
                result(SHT_rv) &
                bind(C, name="returnStructByValue")
            use iso_c_binding, only : C_DOUBLE, C_INT
            import :: cstruct1
            implicit none
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
            type(cstruct1) :: SHT_rv
        end function return_struct_by_value
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr1
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        function c_return_struct_ptr1(i, d) &
                result(SHT_rv) &
                bind(C, name="returnStructPtr1")
            use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR
            implicit none
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
            type(C_PTR) SHT_rv
        end function c_return_struct_ptr1
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr1
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        function c_return_struct_ptr1_bufferify(i, d) &
                result(SHT_rv) &
                bind(C, name="returnStructPtr1")
            use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR
            implicit none
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
            type(C_PTR) SHT_rv
        end function c_return_struct_ptr1_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr2
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +intent(out)
    ! Requested: c_out_char_*
    ! Match:     c_default
    interface
        function c_return_struct_ptr2(i, d, outbuf) &
                result(SHT_rv) &
                bind(C, name="returnStructPtr2")
            use iso_c_binding, only : C_CHAR, C_DOUBLE, C_INT, C_PTR
            implicit none
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
            character(kind=C_CHAR), intent(OUT) :: outbuf(*)
            type(C_PTR) SHT_rv
        end function c_return_struct_ptr2
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr2
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    interface
        function c_return_struct_ptr2_bufferify(i, d, outbuf, &
                SHT_outbuf_len) &
                result(SHT_rv) &
                bind(C, name="STR_return_struct_ptr2_bufferify")
            use iso_c_binding, only : C_CHAR, C_DOUBLE, C_INT, C_PTR
            implicit none
            integer(C_INT), value, intent(IN) :: i
            real(C_DOUBLE), value, intent(IN) :: d
            character(kind=C_CHAR), intent(OUT) :: outbuf(*)
            integer(C_INT), value, intent(IN) :: SHT_outbuf_len
            type(C_PTR) SHT_rv
        end function c_return_struct_ptr2_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct_list * get_global_struct_list
    ! Attrs:     +deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_pointer
    ! Match:     c_function_struct_*
    interface
        function c_get_global_struct_list() &
                result(SHT_rv) &
                bind(C, name="get_global_struct_list")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_global_struct_list
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct_list * get_global_struct_list
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    interface
        function c_get_global_struct_list_bufferify() &
                result(SHT_rv) &
                bind(C, name="get_global_struct_list")
            use iso_c_binding, only : C_PTR
            implicit none
            type(C_PTR) SHT_rv
        end function c_get_global_struct_list_bufferify
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct_as_class * Create_Cstruct_as_class
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! start c_create__cstruct_as_class
    interface
        subroutine c_create__cstruct_as_class(SHT_rv) &
                bind(C, name="STR_create__cstruct_as_class")
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv
        end subroutine c_create__cstruct_as_class
    end interface
    ! end c_create__cstruct_as_class

    ! ----------------------------------------
    ! Function:  Cstruct_as_class * Create_Cstruct_as_class_args
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! ----------------------------------------
    ! Argument:  int x +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int y +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        subroutine c_create__cstruct_as_class_args(SHT_rv, x, y) &
                bind(C, name="STR_create__cstruct_as_class_args")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            integer(C_INT), value, intent(IN) :: x
            integer(C_INT), value, intent(IN) :: y
        end subroutine c_create__cstruct_as_class_args
    end interface

    ! ----------------------------------------
    ! Function:  int Cstruct_as_class_sum
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct_as_class * point +pass
    ! Attrs:     +intent(in)
    ! Requested: c_in_shadow_*
    ! Match:     c_in_shadow
    interface
        function c_cstruct_as_class_sum(point) &
                result(SHT_rv) &
                bind(C, name="STR_cstruct_as_class_sum")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(IN) :: point
            integer(C_INT) :: SHT_rv
        end function c_cstruct_as_class_sum
    end interface

    ! ----------------------------------------
    ! Function:  Cstruct_as_subclass * Create_Cstruct_as_subclass_args
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! ----------------------------------------
    ! Argument:  int x +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int y +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int z +value
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    interface
        subroutine c_create__cstruct_as_subclass_args(SHT_rv, x, y, z) &
                bind(C, name="STR_create__cstruct_as_subclass_args")
            use iso_c_binding, only : C_INT
            import :: STR_SHROUD_capsule_data
            implicit none
            type(STR_SHROUD_capsule_data), intent(OUT) :: SHT_rv
            integer(C_INT), value, intent(IN) :: x
            integer(C_INT), value, intent(IN) :: y
            integer(C_INT), value, intent(IN) :: z
        end subroutine c_create__cstruct_as_subclass_args
    end interface

    interface
        ! splicer begin additional_interfaces
        ! splicer end additional_interfaces
    end interface

    ! start generic interface Cstruct_as_class
    interface Cstruct_as_class
        module procedure create__cstruct_as_class
        module procedure create__cstruct_as_class_args
    end interface Cstruct_as_class
    ! end generic interface Cstruct_as_class

    interface Cstruct_as_subclass
        module procedure create__cstruct_as_subclass_args
    end interface Cstruct_as_subclass

contains

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getX1
    ! Attrs:     +intent(getter)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(getter)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start cstruct_as_class_get_x1
    function cstruct_as_class_get_x1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_class) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Cstruct_as_class.method.get_x1
        SHT_rv = c_cstruct_as_class_get_x1(obj%cxxmem)
        ! splicer end class.Cstruct_as_class.method.get_x1
    end function cstruct_as_class_get_x1
    ! end cstruct_as_class_get_x1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setX1
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start cstruct_as_class_set_x1
    subroutine cstruct_as_class_set_x1(obj, val)
        use iso_c_binding, only : C_INT
        class(cstruct_as_class) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Cstruct_as_class.method.set_x1
        call c_cstruct_as_class_set_x1(obj%cxxmem, val)
        ! splicer end class.Cstruct_as_class.method.set_x1
    end subroutine cstruct_as_class_set_x1
    ! end cstruct_as_class_set_x1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getY1
    ! Attrs:     +intent(getter)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(getter)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start cstruct_as_class_get_y1
    function cstruct_as_class_get_y1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_class) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Cstruct_as_class.method.get_y1
        SHT_rv = c_cstruct_as_class_get_y1(obj%cxxmem)
        ! splicer end class.Cstruct_as_class.method.get_y1
    end function cstruct_as_class_get_y1
    ! end cstruct_as_class_get_y1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setY1
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start cstruct_as_class_set_y1
    subroutine cstruct_as_class_set_y1(obj, val)
        use iso_c_binding, only : C_INT
        class(cstruct_as_class) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Cstruct_as_class.method.set_y1
        call c_cstruct_as_class_set_y1(obj%cxxmem, val)
        ! splicer end class.Cstruct_as_class.method.set_y1
    end subroutine cstruct_as_class_set_y1
    ! end cstruct_as_class_set_y1

    ! splicer begin class.Cstruct_as_class.additional_functions
    ! splicer end class.Cstruct_as_class.additional_functions

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getX1
    ! Attrs:     +intent(getter)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(getter)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start cstruct_as_subclass_get_x1
    function cstruct_as_subclass_get_x1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Cstruct_as_subclass.method.get_x1
        SHT_rv = c_cstruct_as_subclass_get_x1(obj%cxxmem)
        ! splicer end class.Cstruct_as_subclass.method.get_x1
    end function cstruct_as_subclass_get_x1
    ! end cstruct_as_subclass_get_x1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setX1
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start cstruct_as_subclass_set_x1
    subroutine cstruct_as_subclass_set_x1(obj, val)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Cstruct_as_subclass.method.set_x1
        call c_cstruct_as_subclass_set_x1(obj%cxxmem, val)
        ! splicer end class.Cstruct_as_subclass.method.set_x1
    end subroutine cstruct_as_subclass_set_x1
    ! end cstruct_as_subclass_set_x1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getY1
    ! Attrs:     +intent(getter)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(getter)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start cstruct_as_subclass_get_y1
    function cstruct_as_subclass_get_y1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Cstruct_as_subclass.method.get_y1
        SHT_rv = c_cstruct_as_subclass_get_y1(obj%cxxmem)
        ! splicer end class.Cstruct_as_subclass.method.get_y1
    end function cstruct_as_subclass_get_y1
    ! end cstruct_as_subclass_get_y1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setY1
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start cstruct_as_subclass_set_y1
    subroutine cstruct_as_subclass_set_y1(obj, val)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Cstruct_as_subclass.method.set_y1
        call c_cstruct_as_subclass_set_y1(obj%cxxmem, val)
        ! splicer end class.Cstruct_as_subclass.method.set_y1
    end subroutine cstruct_as_subclass_set_y1
    ! end cstruct_as_subclass_set_y1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  int getZ1
    ! Attrs:     +intent(getter)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(getter)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! start cstruct_as_subclass_get_z1
    function cstruct_as_subclass_get_z1(obj) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT) :: SHT_rv
        ! splicer begin class.Cstruct_as_subclass.method.get_z1
        SHT_rv = c_cstruct_as_subclass_get_z1(obj%cxxmem)
        ! splicer end class.Cstruct_as_subclass.method.get_z1
    end function cstruct_as_subclass_get_z1
    ! end cstruct_as_subclass_get_z1

    ! Generated by getter/setter
    ! ----------------------------------------
    ! Function:  void setZ1
    ! Attrs:     +intent(setter)
    ! Exact:     f_setter
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter
    ! ----------------------------------------
    ! Argument:  int val +intent(in)+value
    ! Attrs:     +intent(setter)
    ! Requested: f_setter_native_scalar
    ! Match:     f_setter_native
    ! Attrs:     +intent(setter)
    ! Exact:     c_setter_native_scalar
    ! start cstruct_as_subclass_set_z1
    subroutine cstruct_as_subclass_set_z1(obj, val)
        use iso_c_binding, only : C_INT
        class(cstruct_as_subclass) :: obj
        integer(C_INT), value, intent(IN) :: val
        ! splicer begin class.Cstruct_as_subclass.method.set_z1
        call c_cstruct_as_subclass_set_z1(obj%cxxmem, val)
        ! splicer end class.Cstruct_as_subclass.method.set_z1
    end subroutine cstruct_as_subclass_set_z1
    ! end cstruct_as_subclass_set_z1

    ! splicer begin class.Cstruct_as_subclass.additional_functions
    ! splicer end class.Cstruct_as_subclass.additional_functions

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  int passStruct2
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct1 * s1
    ! Attrs:     +intent(in)
    ! Requested: f_in_struct_*
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_struct_*
    ! Match:     c_in_struct
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    !>
    !! Pass name argument which will build a bufferify function.
    !<
    function pass_struct2(s1, outbuf) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        type(cstruct1), intent(IN) :: s1
        character(len=*), intent(OUT) :: outbuf
        integer(C_INT) :: SHT_rv
        ! splicer begin function.pass_struct2
        SHT_rv = c_pass_struct2_bufferify(s1, outbuf, &
            len(outbuf, kind=C_INT))
        ! splicer end function.pass_struct2
    end function pass_struct2

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr1
    ! Attrs:     +deref(pointer)+intent(function)
    ! Exact:     f_function_struct_*_buf_pointer
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    !>
    !! \brief Return a pointer to a struct
    !!
    !! Does not generate a bufferify C wrapper.
    !<
    function return_struct_ptr1(i, d) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR, c_f_pointer
        type(cstruct1), pointer :: SHT_rv
        integer(C_INT), value, intent(IN) :: i
        real(C_DOUBLE), value, intent(IN) :: d
        ! splicer begin function.return_struct_ptr1
        type(C_PTR) :: SHT_ptr
        SHT_ptr = c_return_struct_ptr1_bufferify(i, d)
        call c_f_pointer(SHT_ptr, SHT_rv)
        ! splicer end function.return_struct_ptr1
    end function return_struct_ptr1

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  Cstruct1 * returnStructPtr2
    ! Attrs:     +deref(pointer)+intent(function)
    ! Exact:     f_function_struct_*_buf_pointer
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    ! ----------------------------------------
    ! Argument:  int i +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  double d +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  char * outbuf +charlen(LENOUTBUF)+intent(out)
    ! Attrs:     +intent(out)
    ! Exact:     f_out_char_*_buf
    ! Attrs:     +api(buf)+intent(out)
    ! Exact:     c_out_char_*_buf
    !>
    !! \brief Return a pointer to a struct
    !!
    !! Generates a bufferify C wrapper function.
    !<
    function return_struct_ptr2(i, d, outbuf) &
            result(SHT_rv)
        use iso_c_binding, only : C_DOUBLE, C_INT, C_PTR, c_f_pointer
        type(cstruct1), pointer :: SHT_rv
        integer(C_INT), value, intent(IN) :: i
        real(C_DOUBLE), value, intent(IN) :: d
        character(len=*), intent(OUT) :: outbuf
        ! splicer begin function.return_struct_ptr2
        type(C_PTR) :: SHT_ptr
        SHT_ptr = c_return_struct_ptr2_bufferify(i, d, outbuf, &
            len(outbuf, kind=C_INT))
        call c_f_pointer(SHT_ptr, SHT_rv)
        ! splicer end function.return_struct_ptr2
    end function return_struct_ptr2

    ! Generated by arg_to_buffer
    ! ----------------------------------------
    ! Function:  Cstruct_list * get_global_struct_list
    ! Attrs:     +deref(pointer)+intent(function)
    ! Exact:     f_function_struct_*_buf_pointer
    ! Attrs:     +api(buf)+deref(pointer)+intent(function)
    ! Requested: c_function_struct_*_buf_pointer
    ! Match:     c_function_struct_*
    function get_global_struct_list() &
            result(SHT_rv)
        use iso_c_binding, only : C_PTR, c_f_pointer
        type(cstruct_list), pointer :: SHT_rv
        ! splicer begin function.get_global_struct_list
        type(C_PTR) :: SHT_ptr
        SHT_ptr = c_get_global_struct_list_bufferify()
        call c_f_pointer(SHT_ptr, SHT_rv)
        ! splicer end function.get_global_struct_list
    end function get_global_struct_list

    ! ----------------------------------------
    ! Function:  Cstruct_as_class * Create_Cstruct_as_class
    ! Attrs:     +intent(function)
    ! Requested: f_function_shadow_*
    ! Match:     f_function_shadow
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! start create__cstruct_as_class
    function create__cstruct_as_class() &
            result(SHT_rv)
        type(cstruct_as_class) :: SHT_rv
        ! splicer begin function.create__cstruct_as_class
        call c_create__cstruct_as_class(SHT_rv%cxxmem)
        ! splicer end function.create__cstruct_as_class
    end function create__cstruct_as_class
    ! end create__cstruct_as_class

    ! ----------------------------------------
    ! Function:  Cstruct_as_class * Create_Cstruct_as_class_args
    ! Attrs:     +intent(function)
    ! Requested: f_function_shadow_*
    ! Match:     f_function_shadow
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! ----------------------------------------
    ! Argument:  int x +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int y +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    function create__cstruct_as_class_args(x, y) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: x
        integer(C_INT), value, intent(IN) :: y
        type(cstruct_as_class) :: SHT_rv
        ! splicer begin function.create__cstruct_as_class_args
        call c_create__cstruct_as_class_args(SHT_rv%cxxmem, x, y)
        ! splicer end function.create__cstruct_as_class_args
    end function create__cstruct_as_class_args

    ! ----------------------------------------
    ! Function:  int Cstruct_as_class_sum
    ! Attrs:     +intent(function)
    ! Requested: f_function_native_scalar
    ! Match:     f_function
    ! Attrs:     +intent(function)
    ! Requested: c_function_native_scalar
    ! Match:     c_function
    ! ----------------------------------------
    ! Argument:  const Cstruct_as_class * point +pass
    ! Attrs:     +intent(in)
    ! Requested: f_in_shadow_*
    ! Match:     f_in_shadow
    ! Attrs:     +intent(in)
    ! Requested: c_in_shadow_*
    ! Match:     c_in_shadow
    function cstruct_as_class_sum(point) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        class(cstruct_as_class), intent(IN) :: point
        integer(C_INT) :: SHT_rv
        ! splicer begin function.sum
        SHT_rv = c_cstruct_as_class_sum(point%cxxmem)
        ! splicer end function.sum
    end function cstruct_as_class_sum

    ! ----------------------------------------
    ! Function:  Cstruct_as_subclass * Create_Cstruct_as_subclass_args
    ! Attrs:     +intent(function)
    ! Requested: f_function_shadow_*
    ! Match:     f_function_shadow
    ! Attrs:     +intent(function)
    ! Requested: c_function_shadow_*
    ! Match:     c_function_shadow
    ! ----------------------------------------
    ! Argument:  int x +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int y +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    ! ----------------------------------------
    ! Argument:  int z +value
    ! Attrs:     +intent(in)
    ! Requested: f_in_native_scalar
    ! Match:     f_default
    ! Attrs:     +intent(in)
    ! Requested: c_in_native_scalar
    ! Match:     c_default
    function create__cstruct_as_subclass_args(x, y, z) &
            result(SHT_rv)
        use iso_c_binding, only : C_INT
        integer(C_INT), value, intent(IN) :: x
        integer(C_INT), value, intent(IN) :: y
        integer(C_INT), value, intent(IN) :: z
        type(cstruct_as_subclass) :: SHT_rv
        ! splicer begin function.create__cstruct_as_subclass_args
        call c_create__cstruct_as_subclass_args(SHT_rv%cxxmem, x, y, z)
        ! splicer end function.create__cstruct_as_subclass_args
    end function create__cstruct_as_subclass_args

    ! splicer begin additional_functions
    ! splicer end additional_functions

    function cstruct_as_class_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(cstruct_as_class), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function cstruct_as_class_eq

    function cstruct_as_class_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(cstruct_as_class), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function cstruct_as_class_ne

    function cstruct_as_subclass_eq(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(cstruct_as_subclass), intent(IN) ::a,b
        logical :: rv
        if (c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function cstruct_as_subclass_eq

    function cstruct_as_subclass_ne(a,b) result (rv)
        use iso_c_binding, only: c_associated
        type(cstruct_as_subclass), intent(IN) ::a,b
        logical :: rv
        if (.not. c_associated(a%cxxmem%addr, b%cxxmem%addr)) then
            rv = .true.
        else
            rv = .false.
        endif
    end function cstruct_as_subclass_ne

end module struct_mod
