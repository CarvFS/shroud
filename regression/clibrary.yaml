copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2019, Lawrence Livermore National Security, LLC.'
-
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
-
- 'All rights reserved.'
-
- 'This file is part of Shroud.'
-
- 'For details about use and distribution, please read LICENSE.'
-
- '#######################################################################'

# Wrap a C library
# Many of the same function as Tutorial, but for C.

library: Clibrary
cxx_header: clibrary.h

language: c

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: False

declarations:

- decl: typedef int TypeID;

- decl: typedef int EnumTypeID
  fields:
    c_to_cxx : static_cast<EnumTypeID>({c_var})
    cxx_to_c : static_cast<int>({cxx_var})

- decl: void Function1()
- decl: double Function2(double arg1, int arg2)
- decl: void Sum(int len +implied(size(values)),
                 int *values +dimension(:)+intent(in),
                 int *result +intent(out))
  options:
    # unable to deal with dimension
    wrap_lua: False

- decl: bool Function3(bool arg)
- decl: void Function3b(const bool arg1, bool *arg2+intent(out), bool *arg3+intent(inout))

- decl: char *Function4a(
    const char *arg1,
    const char *arg2 ) +len(30)

- decl: int ImpliedLen(const char *text, int ltext+implied(len(text)))
  options:
    F_create_bufferify_function: false
  doxygen:
    brief: Return the implied argument - text length
    description: |
       Pass the Fortran length of the char argument directy to the C function.
       No need for the bufferify version which will needlessly copy the string.

- decl: int ImpliedLenTrim(const char *text, int ltext+implied(len_trim(text)))
  options:
    F_create_bufferify_function: false
  doxygen:
    brief: Return the implied argument - text length
    description: |
       Pass the Fortran length of the char argument directy to the C function.
       No need for the bufferify version which will needlessly copy the string.

# XXX - Replace with other code to free memory
#  format:
#    C_finalize_buf: |
#       // Function4a allocates memory which must be released after it is copied
#       // into the Fortran argument or else it will leak.
#       free({cxx_var});

##-- decl: const std::string& Function4b(
##-    const std::string& arg1,
##-    const std::string& arg2 )
##-  options:
##-    F_string_result_as_arg: output

##-- decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
##-  default_arg_suffix:
##-  -  
##-  -  _arg1
##-  -  _arg1_arg2

##-- decl: void Function6(const std::string& name)
##-  function_suffix: _from_name
##-- decl: void Function6(int indx)
##-  function_suffix: _from_index
##-
##-- decl: void Function7(ArgType arg)
##-  cxx_template:
##-    ArgType:
##-    - int
##-    - double
##-
##-- decl: RetType Function8()
##-  cxx_template:
##-    RetType:
##-    - int
##-    - double
##-
##-- decl: void Function9(double arg)
##-  fortran_generic:
##-     arg:
##-     - float
##-     - double
##-
##-# test cxx_template, fortran_generic, overload
##-#- decl: void Function10()
##-#- decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
##-#  options:
##-#    F_string_len_trim: True
##-#  cxx_template:
##-#    ArgType:
##-#    - int
##-#    - double
##-#  fortran_generic:
##-#     arg2:
##-#     - float
##-#     - double
##-
##-
##-# test fortran_generic, overload
##-- decl: void Function10()
##-- decl: void Function10(const std::string &name, double arg2)
##-  options:
##-    F_string_len_trim: True
##-#  cxx_template:
##-#    ArgType:
##-#    - int
##-#    - double
##-  fortran_generic:
##-     arg2:
##-     - float
##-     - double
##-
##-# overload with optional
##-- decl: int overload1(int num,
##-          int offset = 0, int stride = 1)
##-  default_arg_suffix:
##-  - _num
##-  - _num_offset
##-  - _num_offset_stride
##-- decl: int overload1(double type, int num,
##-          int offset = 0, int stride = 1)
##-
##-# test F_string_result_as_arg and optional arguments
##-#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
##-#  options:
##-#    F_string_result_as_arg: output
##-
##-# TypeID and DataTypeId must be define in types
##-- decl: TypeID typefunc(TypeID arg)
##-- decl: EnumTypeID enumfunc(EnumTypeID arg)
##-
##-- decl: void useclass(const Class1 *arg1) 
##-  options:
##-    wrap_lua: False
##-
##-# parser does not recognized **
##-#- decl: void getclass(const Class1 **arg1) 
##-#  options:
##-#    wrap_python: False
##-#    wrap_lua: False
##-
##-# test std::vector
##-# const implies intent(in)
##-- decl: int vector_sum(const std::vector<int> &arg)
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-- decl: void vector_iota(std::vector<int> &arg+intent(out))
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-# defaults to intent(inout)
##-- decl: void vector_increment(std::vector<int> &arg)
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-# does multidimensional make sense.  Need to call shape
##-#- decl: void vector1XXX(std::vector<int> &arg+dimension(:,:))
##-
##--  decl: int vector_string_count(const std::vector< std::string > &arg)
##-   doxygen:
##-     brief: count number of underscore in vector of strings
##-     decription: |
##-       The input will be copied in order to create the C++ argument
##-
##--  decl: void vector_string_fill(std::vector< std::string > &arg+intent(out))
##-   C_return_type: int
##-   C_return_code: return SH_arg.size();
##-   doxygen:
##-     brief: Fill in arg with some animal names
##-     description: |
##-       The C++ function returns void. But the C and Fortran wrappers return
##-       an int with the number of items added to arg.
##-
##--  decl: void vector_string_append(std::vector< std::string > &arg+intent(inout))
##-   doxygen:
##-     brief: append '-like' to names.
##-

 
##-##################################################
##-
##-# Used with testing
##-- decl: const std::string& LastFunctionCalled()
##-
##-##################################################
##-
##-- class: Class1
##-  declarations:
##-  - decl: Class1()  +name(new)
##-  - decl: ~Class1() +name(delete)
##-  - decl: void Method1()
