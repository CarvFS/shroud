copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2019, Lawrence Livermore National Security, LLC.'
-
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
-
- 'All rights reserved.'
-
- 'This file is part of Shroud.'
-
- 'For details about use and distribution, please read LICENSE.'
-
- '#######################################################################'

# Create a runnable program for the tutorial

library: Tutorial
cxx_header: tutorial.hpp

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: True


declarations:
- decl: extern int global_flag;
- decl: namespace tutorial
  declarations:

  - decl: typedef int TypeID;

  - decl: typedef int EnumTypeID
    fields:
      c_to_cxx : static_cast<tutorial::EnumTypeID>({c_var})
      cxx_to_c : static_cast<int>({cxx_var})

  - decl: |
        enum Color {
          RED,
          BLUE,
          WHITE
        };
    options:
       bar: 4
    format:
       baz: 4

  - decl: |
      struct struct1 {
        int ifield;
        double dfield;
      };

  - decl: extern int tutorial_flag;

  - decl: void Function1()
  - decl: double Function2(double arg1, int arg2)
  - decl: void Sum(size_t len  +implied(size(values)),
                   int *values +dimension(:)+intent(in),
                   int *result +intent(out))
    options:
      # unable to deal with dimension
      wrap_lua: False
  
  - decl: long long TypeLongLong(long long arg1)
    options:
       # No long long in Lua
       wrap_lua: False
  
  - decl: bool Function3(bool arg)
  - decl: void Function3b(const bool arg1, bool *arg2+intent(out), bool *arg3+intent(inout))
    options:
      # check out arguments
      wrap_python: False
      wrap_lua: False

  - decl: const std::string Function4a(
      const std::string& arg1,
      const std::string& arg2 ) +len(30)
#  attrs:
#    result:
#      len: 30
    doxygen:
      description: |
         Since +len(30) is provided, the result of the function
         will be copied directly into memory provided by Fortran.
         The function will not be ALLOCATABLE.

  - decl: const std::string& Function4b(
      const std::string& arg1,
      const std::string& arg2 )
    format:
      F_string_result_as_arg: output

  - decl: const std::string Function4c(
      const std::string& arg1,
      const std::string& arg2 )
    doxygen:
      description: |
         Note that since a reference is returned, no intermediate string
         is allocated.  It is assumed +owner(library).
  
  - decl: const std::string * Function4d() +owner(caller)
# XXX - can not deal with non const yet
    doxygen:
      description: |
         A string is allocated by the library is must be deleted
         by the caller.
  
  - decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
    default_arg_suffix:
    -  
    -  _arg1
    -  _arg1_arg2
  
# overloaded functions
  - decl: void Function6(const std::string& name)
    format:
      function_suffix: _from_name
  - decl: void Function6(int indx)
    format:
      function_suffix: _from_index
  
  - decl: |
        template<typename ArgType>
        void Function7(ArgType arg)
    cxx_template:
    - instantiation: <int>
    - instantiation: <double>

  
  - decl: template<typename RetType> RetType Function8()
    cxx_template:
    - instantiation: <int>
    - instantiation: <double>
    options:
       wrap_lua: False
       wrap_python: False
  
  - decl: void Function9(double arg)
    fortran_generic:
       arg:
       - float
       - double
  
# test cxx_template, fortran_generic, overload
#- decl: void Function10()
#- decl: template<typename ArgType> void Function10(ArgType arg1, std::string &name, double arg2 = 0)
#  options:
#    F_string_len_trim: True
#  cxx_template:
#  - instantiation: <int>
#  - instantiation: <double>
#  cxx_template:
#    ArgType:
#    - int
#    - double
#  fortran_generic:
#     arg2:
#     - float
#     - double
  
  
# test fortran_generic, overload
  - decl: void Function10()
  - decl: void Function10(const std::string &name, double arg2)
    options:
      F_string_len_trim: True
#   cxx_template:
#   - instantiation: <int>
#   - instantiation: <double>
    fortran_generic:
       arg2:
       - float
       - double
  
# overload with optional
  - decl: int overload1(int num,
            int offset = 0, int stride = 1)
    default_arg_suffix:
    - _num
    - _num_offset
    - _num_offset_stride
  - decl: int overload1(double type, int num,
            int offset = 0, int stride = 1)
  
# test F_string_result_as_arg and optional arguments
#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
#  format:
#    F_string_result_as_arg: output
  
# TypeID and DataTypeId must be define in types
  - decl: TypeID typefunc(TypeID arg)
  - decl: EnumTypeID enumfunc(EnumTypeID arg)
  - decl: Color colorfunc(Color arg);
  
  - decl: void getMinMax(int &min +intent(out), int &max +intent(out))
    doxygen:
       brief: Pass in reference to scalar
    options:
      wrap_lua: False
  
##################################################
  
  - decl: class Class1
    declarations:
    - decl: int m_flag +readonly;
    - decl: int m_test +name(test);
    - decl: Class1()         +name(new)
      format:
        function_suffix: _default
    - decl: Class1(int flag) +name(new)
      format:
        function_suffix: _flag
    - decl: ~Class1()        +name(delete)
    - decl: int Method1()
      doxygen:
         brief: returns the value of flag member
  
    - decl: bool equivalent(Class1 const &obj2) const;
      # Note that Fortran adds an obj argument so use obj2 instead.
      doxygen:
         brief: Pass in reference to instance
      options:
         # Need to fix fmt.cxx_deref
         wrap_lua: False

    - decl: Class1 * returnThis();
      return_this: True
      doxygen:
         brief: Return pointer to 'this' to allow chaining calls
      options:
         wrap_python: False
         wrap_lua: False
  
    - decl: Class1 * returnThisBuffer(std::string & name +intent(in), bool flag);
      # do not set return_this
      # passing in a string will cause node.generated_suffix to be set to '_buf'.
      # but result is not bufferified so look for c_statements['result'], not
      # 'result_buf'.

      # The bool argument tests that wrapf.py does not use _generated_suffix
      # since it only applies to the generated C function.

      doxygen:
         brief: Return pointer to 'this' to allow chaining calls
      options:
         wrap_python: False
         wrap_lua: False
  
    - decl: Class1 *getclass3() const
      doxygen:
         brief: Test const method
# This test is compile only to make sure it is not PURE
      options:
#      wrap_python: False
        wrap_lua: False

    - decl: enum DIRECTION { UP = 2, DOWN, LEFT= 100, RIGHT };
  
    - decl: DIRECTION directionFunc(DIRECTION arg);
  
##################################################

  - decl: Class1::DIRECTION directionFunc(Class1::DIRECTION arg);
  
#  - decl: void passClassByValue(Class1 arg)
#    doxygen:
#         brief: Pass arguments to a function.
#    options:
#      wrap_python: False
#      wrap_lua: False
  
  - decl: int useclass(const Class1 *arg)
    options:
      wrap_lua: False
  
# parser does not recognized **
#- decl: void getclass(const Class1 **arg1) 
#  options:
#    wrap_python: False
#    wrap_lua: False
  
  - decl: const Class1 *getclass2() 
    options:
      # const issues with python
      wrap_python: False
      wrap_lua: False
  
  - decl: Class1 *getclass3() 
    options:
#    wrap_python: False
      wrap_lua: False
  
  - decl: Class1 getClassCopy(int flag)
    doxygen:
         brief: Return Class1 instance by value, uses copy constructor
    options:
      wrap_python: False
      wrap_lua: False

##################################################
  
  - decl: int callback1(int in, int (*incr)(int));
    options:
      wrap_lua: False
      wrap_python: False
  
##################################################

  - decl: struct1 returnStruct(int i, double d);
    options:
      wrap_lua: False
  - decl: struct1 *returnStructPtr(int i, double d);
    options:
      wrap_lua: False
#  - decl: struct1 *returnStructPtrNew(int i, double d);
#    options:
#      wrap_lua: False
#      wrap_python: False
#  - decl: void freeStruct(struct1 *arg1);
#    options:
#      wrap_lua: False
#      wrap_python: False

  - decl: double acceptStructIn(struct1 arg)
    options:
      wrap_lua: False
      wrap_python: False
  - decl: double acceptStructInPtr(struct1 *arg+intent(in))
    options:
      wrap_lua: False
      wrap_python: False
  - decl: void acceptStructOutPtr(struct1 *arg +intent(out), int i, double d)
    options:
      wrap_lua: False
      wrap_python: False
  - decl: void acceptStructInOutPtr(struct1 *arg +intent(inout))
    options:
      wrap_lua: False
      wrap_python: False

##################################################
# Used with testing
  - decl: const std::string& LastFunctionCalled() +len(30)

##########
  
- decl: class Singleton
  options:
    wrap_lua: false
  declarations:
#  - decl: static Singleton* instancePtr()
  - decl: static Singleton& getReference()
  
  
##################################################
# Files which contain code to be inserted into generated code
splicer:
#  c:
#  -  ctutorialsplicer.c
  f:
  -  ftutorialsplicer.f
