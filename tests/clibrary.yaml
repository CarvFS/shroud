copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.'
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
- 'All rights reserved.'
-
- 'This file is part of Shroud.  For details, see'
- 'https://github.com/LLNL/shroud. Please also read shroud/LICENSE.'
-
- 'Redistribution and use in source and binary forms, with or without'
- 'modification, are permitted provided that the following conditions are'
- 'met:'
-
- '* Redistributions of source code must retain the above copyright'
- '  notice, this list of conditions and the disclaimer below.'
- 
- '* Redistributions in binary form must reproduce the above copyright'
- '  notice, this list of conditions and the disclaimer (as noted below)'
- '  in the documentation and/or other materials provided with the'
- '  distribution.'
-
- '* Neither the name of the LLNS/LLNL nor the names of its contributors'
- '  may be used to endorse or promote products derived from this'
- '  software without specific prior written permission.'
-
- 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS'
- '"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT'
- 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR'
- 'A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE'
- 'LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR'
- 'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,'
- 'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,'
- 'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR'
- 'PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF'
- 'LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING'
- 'NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS'
- 'SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'
-
- '#######################################################################'

# Wrap a C library
# Many of the same function as Tutorial, but for C.

library: Clibrary
cxx_header: clibrary.h

language: c

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: False


types:
  TypeID:
    typedef  : int
    cxx_type : TypeID

  EnumTypeID:
    typedef  : int
    cxx_type : EnumTypeID
    c_to_cxx : static_cast<EnumTypeID>({c_var})
    cxx_to_c : static_cast<int>({cxx_var})


functions:
- decl: void Function1()
- decl: double Function2(double arg1, int arg2)
- decl: void Sum(int len +implied(size(values)),
                 int *values +dimension(:)+intent(in),
                 int *result +intent(out))
  options:
    # unable to deal with dimension
    wrap_lua: False

- decl: bool Function3(bool arg)
- decl: void Function3b(const bool arg1, bool *arg2+intent(out), bool *arg3+intent(inout))

- decl: char *Function4a(
    const char *arg1,
    const char *arg2 ) +len(30)
  format:
    C_finalize_buf: |
       // Function4a allocates memory which must be released after it is copied
       // into the Fortran argument or else it will leak.
       free({cxx_var});
# +pure

##-- decl: const std::string& Function4b(
##-    const std::string& arg1,
##-    const std::string& arg2 )
##-  options:
##-    F_string_result_as_arg: output

##-- decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
##-  default_arg_suffix:
##-  -  
##-  -  _arg1
##-  -  _arg1_arg2

##-- decl: void Function6(const std::string& name)
##-  function_suffix: _from_name
##-- decl: void Function6(int indx)
##-  function_suffix: _from_index
##-
##-- decl: void Function7(ArgType arg)
##-  cxx_template:
##-    ArgType:
##-    - int
##-    - double
##-
##-- decl: RetType Function8()
##-  cxx_template:
##-    RetType:
##-    - int
##-    - double
##-
##-- decl: void Function9(double arg)
##-  fortran_generic:
##-     arg:
##-     - float
##-     - double
##-
##-# test cxx_template, fortran_generic, overload
##-#- decl: void Function10()
##-#- decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
##-#  options:
##-#    F_string_len_trim: True
##-#  cxx_template:
##-#    ArgType:
##-#    - int
##-#    - double
##-#  fortran_generic:
##-#     arg2:
##-#     - float
##-#     - double
##-
##-
##-# test fortran_generic, overload
##-- decl: void Function10()
##-- decl: void Function10(const std::string &name, double arg2)
##-  options:
##-    F_string_len_trim: True
##-#  cxx_template:
##-#    ArgType:
##-#    - int
##-#    - double
##-  fortran_generic:
##-     arg2:
##-     - float
##-     - double
##-
##-# overload with optional
##-- decl: int overload1(int num,
##-          int offset = 0, int stride = 1)
##-  default_arg_suffix:
##-  - _num
##-  - _num_offset
##-  - _num_offset_stride
##-- decl: int overload1(double type, int num,
##-          int offset = 0, int stride = 1)
##-
##-# test F_string_result_as_arg and optional arguments
##-#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
##-#  options:
##-#    F_string_result_as_arg: output
##-
##-# TypeID and DataTypeId must be define in types
##-- decl: TypeID typefunc(TypeID arg)
##-- decl: EnumTypeID enumfunc(EnumTypeID arg)
##-
##-- decl: void useclass(const Class1 *arg1) 
##-  options:
##-    wrap_lua: False
##-
##-# parser does not recognized **
##-#- decl: void getclass(const Class1 **arg1) 
##-#  options:
##-#    wrap_python: False
##-#    wrap_lua: False
##-
##-# test std::vector
##-# const implies intent(in)
##-- decl: int vector_sum(const std::vector<int> &arg)
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-- decl: void vector_iota(std::vector<int> &arg+intent(out))
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-# defaults to intent(inout)
##-- decl: void vector_increment(std::vector<int> &arg)
##-  options:
##-    wrap_python: False
##-    wrap_lua: False
##-
##-# does multidimensional make sense.  Need to call shape
##-#- decl: void vector1XXX(std::vector<int> &arg+dimension(:,:))
##-
##--  decl: int vector_string_count(const std::vector< std::string > &arg)
##-   doxygen:
##-     brief: count number of underscore in vector of strings
##-     decription: |
##-       The input will be copied in order to create the C++ argument
##-
##--  decl: void vector_string_fill(std::vector< std::string > &arg+intent(out))
##-   C_return_type: int
##-   C_return_code: return SH_arg.size();
##-   doxygen:
##-     brief: Fill in arg with some animal names
##-     description: |
##-       The C++ function returns void. But the C and Fortran wrappers return
##-       an int with the number of items added to arg.
##-
##--  decl: void vector_string_append(std::vector< std::string > &arg+intent(inout))
##-   doxygen:
##-     brief: append '-like' to names.
##-

-  decl: void  intargs(const int argin      +intent(in),
                             int * arginout +intent(inout),
                             int * argout   +intent(out))

-  decl: void cos_doubles(double * in     +intent(in)  +dimension(:),
                          double * out    +intent(out) +allocatable(mold=in),
                          int      sizein +implied(size(in)))
   doxygen:
     brief: compute cos of IN and save in OUT
     description:
       allocate OUT same type as IN
       implied size of array

-  decl: void truncate_to_int(double * in     +intent(in)  +dimension(:),
                              int *    out    +intent(out) +allocatable(mold=in),
                              int      sizein +implied(size(in)))
   doxygen:
     brief: truncate IN argument and save in OUT
     description: |
       allocate OUT different type as IN
       implied size of array

-  decl: void increment(int * array  +intent(inout)  +dimension(:),
                        int   sizein +implied(size(array)))
   doxygen:
     brief: 
     description: |
       array with intent(INOUT)

 
##-##################################################
##-
##-# Used with testing
##-- decl: const std::string& LastFunctionCalled() +pure
##-
##-##################################################
##-
##-classes:
##-- name: Class1
##-  methods:
##-  - decl: Class1 *new()  +constructor
##-  - decl: void delete()  +destructor
##-  - decl: void Method1()
