copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.'
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
- 'All rights reserved.'
-
- 'This file is part of Shroud.  For details, see'
- 'https://github.com/LLNL/shroud. Please also read shroud/LICENSE.'
-
- 'Redistribution and use in source and binary forms, with or without'
- 'modification, are permitted provided that the following conditions are'
- 'met:'
-
- '* Redistributions of source code must retain the above copyright'
- '  notice, this list of conditions and the disclaimer below.'
- 
- '* Redistributions in binary form must reproduce the above copyright'
- '  notice, this list of conditions and the disclaimer (as noted below)'
- '  in the documentation and/or other materials provided with the'
- '  distribution.'
-
- '* Neither the name of the LLNS/LLNL nor the names of its contributors'
- '  may be used to endorse or promote products derived from this'
- '  software without specific prior written permission.'
-
- 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS'
- '"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT'
- 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR'
- 'A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE'
- 'LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR'
- 'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,'
- 'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,'
- 'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR'
- 'PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF'
- 'LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING'
- 'NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS'
- 'SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'
-
- '#######################################################################'

# Create a runnable program for the tutorial

library: Tutorial
cxx_header: tutorial.hpp
namespace: tutorial

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: True


types:
  TypeID:
    typedef  : int
    cxx_type : TypeID

  EnumTypeID:
    typedef  : int
    cxx_type : EnumTypeID
    c_to_cxx : static_cast<EnumTypeID>({c_var})
    cxx_to_c : static_cast<int>({cxx_var})


functions:
- decl: void Function1()
- decl: double Function2(double arg1, int arg2)
- decl: void Sum(size_t len  +implied(size(values)),
                 int *values +dimension(:)+intent(in),
                 int *result +intent(out))
  options:
    # unable to deal with dimension
    wrap_lua: False

- decl: long long TypeLongLong(long long arg1)
  options:
     # No long long in Lua
     wrap_lua: False

- decl: bool Function3(bool arg)
- decl: void Function3b(const bool arg1, bool *arg2+intent(out), bool *arg3+intent(inout))
  options:
    # check out arguments
    wrap_python: False
    wrap_lua: False

- decl: const std::string Function4a+len(30)(
    const std::string& arg1,
    const std::string& arg2 )
# +pure
#  attrs:
#    result:
#      len: 30
- decl: const std::string& Function4b(
    const std::string& arg1,
    const std::string& arg2 )
  format:
    F_string_result_as_arg: output

- decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
  default_arg_suffix:
  -  
  -  _arg1
  -  _arg1_arg2

# overloaded functions
- decl: void Function6(const std::string& name)
  format:
    function_suffix: _from_name
- decl: void Function6(int indx)
  format:
    function_suffix: _from_index

- decl: void Function7(ArgType arg)
  cxx_template:
    ArgType:
    - int
    - double

- decl: RetType Function8()
  cxx_template:
    RetType:
    - int
    - double

- decl: void Function9(double arg)
  fortran_generic:
     arg:
     - float
     - double

# test cxx_template, fortran_generic, overload
#- decl: void Function10()
#- decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
#  options:
#    F_string_len_trim: True
#  cxx_template:
#    ArgType:
#    - int
#    - double
#  fortran_generic:
#     arg2:
#     - float
#     - double


# test fortran_generic, overload
- decl: void Function10()
- decl: void Function10(const std::string &name, double arg2)
  options:
    F_string_len_trim: True
#  cxx_template:
#    ArgType:
#    - int
#    - double
  fortran_generic:
     arg2:
     - float
     - double

# overload with optional
- decl: int overload1(int num,
          int offset = 0, int stride = 1)
  default_arg_suffix:
  - _num
  - _num_offset
  - _num_offset_stride
- decl: int overload1(double type, int num,
          int offset = 0, int stride = 1)

# test F_string_result_as_arg and optional arguments
#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
#  format:
#    F_string_result_as_arg: output

# TypeID and DataTypeId must be define in types
- decl: TypeID typefunc(TypeID arg)
- decl: EnumTypeID enumfunc(EnumTypeID arg)

- decl: int useclass(const Class1 *arg1) 
  options:
    wrap_lua: False

# parser does not recognized **
#- decl: void getclass(const Class1 **arg1) 
#  options:
#    wrap_python: False
#    wrap_lua: False

- decl: const Class1 *getclass2() 
  options:
    # const issues with python
    wrap_python: False
    wrap_lua: False

- decl: Class1 *getclass3() 
  options:
#    wrap_python: False
    wrap_lua: False

# test std::vector
# const implies intent(in)
- decl: int vector_sum(const std::vector<int> &arg)
  options:
    wrap_python: False
    wrap_lua: False

- decl: void vector_iota(std::vector<int> &arg+intent(out))
  options:
    wrap_python: False
    wrap_lua: False

# defaults to intent(inout)
- decl: void vector_increment(std::vector<int> &arg)
  options:
    wrap_python: False
    wrap_lua: False

# does multidimensional make sense?  Need to call shape
#- decl: void vector1XXX(std::vector<int> &arg+dimension(:,:))

-  decl: int vector_string_count(const std::vector< std::string > &arg)
   doxygen:
     brief: count number of underscore in vector of strings
     decription: |
       The input will be copied in order to create the C++ argument

-  decl: void vector_string_fill(std::vector< std::string > &arg+intent(out))
   format:
     C_return_type: int
     C_return_code: return SH_arg.size();
   doxygen:
     brief: Fill in arg with some animal names
     description: |
       The C++ function returns void. But the C and Fortran wrappers return
       an int with the number of items added to arg.

-  decl: void vector_string_append(std::vector< std::string > &arg+intent(inout))
   doxygen:
     brief: append '-like' to names.

##################################################

-  decl: int callback1(int in, int (*incr)(int));
   options:
     wrap_lua: False
     wrap_python: False

##################################################

# Used with testing
- decl: const std::string& LastFunctionCalled +len(30)()

##################################################

classes:
- name: Class1
  methods:
  - decl: Class1()         +name(new)
    format:
      function_suffix: _default
  - decl: Class1(int flag) +name(new)
    format:
      function_suffix: _flag
  - decl: ~Class1()        +name(delete)
  - decl: int Method1()
    doxygen:
       brief: returns the value of flag member

  - decl: bool equivalent(Class1 const &obj2) const;
    # Note that Fortran adds an obj argument
    doxygen:
       brief: Pass in reference to instance
    options:
       # Need to fix fmt.cxx_deref
       wrap_lua: False



##################################################
# Files which contain code to be inserted into generated code
splicer:
#  c:
#  -  ctutorialsplicer.c
  f:
  -  ftutorialsplicer.f
