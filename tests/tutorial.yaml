copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.'
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
- 'All rights reserved.'
-
- 'This file is part of Shroud.  For details, see'
- 'https://github.com/LLNL/shroud. Please also read shroud/LICENSE.'
-
- 'Redistribution and use in source and binary forms, with or without'
- 'modification, are permitted provided that the following conditions are'
- 'met:'
-
- '* Redistributions of source code must retain the above copyright'
- '  notice, this list of conditions and the disclaimer below.'
- 
- '* Redistributions in binary form must reproduce the above copyright'
- '  notice, this list of conditions and the disclaimer (as noted below)'
- '  in the documentation and/or other materials provided with the'
- '  distribution.'
-
- '* Neither the name of the LLNS/LLNL nor the names of its contributors'
- '  may be used to endorse or promote products derived from this'
- '  software without specific prior written permission.'
-
- 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS'
- '"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT'
- 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR'
- 'A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE'
- 'LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR'
- 'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,'
- 'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,'
- 'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR'
- 'PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF'
- 'LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING'
- 'NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS'
- 'SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'
-
- '#######################################################################'

# Create a runnable program for the tutorial

library: Tutorial
cxx_header: tutorial.hpp

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: True


declarations:
- decl: extern int global_flag;
- decl: namespace tutorial
  declarations:

  - decl: typedef int TypeID;

  - decl: typedef int EnumTypeID
    fields:
      c_to_cxx : static_cast<tutorial::EnumTypeID>({c_var})
      cxx_to_c : static_cast<int>({cxx_var})

  - decl: |
        enum Color {
          RED,
          BLUE,
          WHITE
        };
    options:
       bar: 4
    format:
       baz: 4

  - decl: |
      struct struct1 {
        int ifield;
        double dfield;
      };

  - decl: extern int tutorial_flag;

  - decl: void Function1()
  - decl: double Function2(double arg1, int arg2)
  - decl: void Sum(size_t len  +implied(size(values)),
                   int *values +dimension(:)+intent(in),
                   int *result +intent(out))
    options:
      # unable to deal with dimension
      wrap_lua: False
  
  - decl: long long TypeLongLong(long long arg1)
    options:
       # No long long in Lua
       wrap_lua: False
  
  - decl: bool Function3(bool arg)
  - decl: void Function3b(const bool arg1, bool *arg2+intent(out), bool *arg3+intent(inout))
    options:
      # check out arguments
      wrap_python: False
      wrap_lua: False

  - decl: const std::string Function4a(
      const std::string& arg1,
      const std::string& arg2 ) +len(30)
#  attrs:
#    result:
#      len: 30
  - decl: const std::string& Function4b(
      const std::string& arg1,
      const std::string& arg2 )
    format:
      F_string_result_as_arg: output

  - decl: const std::string& Function4c(
      const std::string& arg1,
      const std::string& arg2 )
  
  - decl: const std::string * Function4d()
# XXX - can not deal with non const yet
  
  - decl: double Function5(double arg1 = 3.1415, bool arg2 = true)
    default_arg_suffix:
    -  
    -  _arg1
    -  _arg1_arg2
  
# overloaded functions
  - decl: void Function6(const std::string& name)
    format:
      function_suffix: _from_name
  - decl: void Function6(int indx)
    format:
      function_suffix: _from_index
  
  - decl: void Function7(ArgType arg)
    cxx_template:
      ArgType:
      - int
      - double
  
  - decl: RetType Function8()
    cxx_template:
      RetType:
      - int
      - double
    options:
       wrap_lua: False
       wrap_python: False
  
  - decl: void Function9(double arg)
    fortran_generic:
       arg:
       - float
       - double
  
# test cxx_template, fortran_generic, overload
#- decl: void Function10()
#- decl: void Function10(ArgType arg1, std::string &name, double arg2 = 0)
#  options:
#    F_string_len_trim: True
#  cxx_template:
#    ArgType:
#    - int
#    - double
#  fortran_generic:
#     arg2:
#     - float
#     - double
  
  
# test fortran_generic, overload
  - decl: void Function10()
  - decl: void Function10(const std::string &name, double arg2)
    options:
      F_string_len_trim: True
#  cxx_template:
#    ArgType:
#    - int
#    - double
    fortran_generic:
       arg2:
       - float
       - double
  
# overload with optional
  - decl: int overload1(int num,
            int offset = 0, int stride = 1)
    default_arg_suffix:
    - _num
    - _num_offset
    - _num_offset_stride
  - decl: int overload1(double type, int num,
            int offset = 0, int stride = 1)
  
# test F_string_result_as_arg and optional arguments
#- decl: const string& overload2(int flag = 0, bool flag2 = true) const
#  format:
#    F_string_result_as_arg: output
  
# TypeID and DataTypeId must be define in types
  - decl: TypeID typefunc(TypeID arg)
  - decl: EnumTypeID enumfunc(EnumTypeID arg)
  - decl: Color colorfunc(Color arg);
  
  - decl: void getMinMax(int &min +intent(out), int &max +intent(out))
    doxygen:
       brief: Pass in reference to scalar
    options:
      wrap_lua: False
  
##################################################
  
  - decl: class Class1
    declarations:
    - decl: int m_flag +readonly;
    - decl: int m_test +name(test);
    - decl: Class1()         +name(new)
      format:
        function_suffix: _default
    - decl: Class1(int flag) +name(new)
      format:
        function_suffix: _flag
    - decl: ~Class1()        +name(delete)
    - decl: int Method1()
      doxygen:
         brief: returns the value of flag member
  
    - decl: bool equivalent(Class1 const &obj2) const;
      # Note that Fortran adds an obj argument so use obj2 instead.
      doxygen:
         brief: Pass in reference to instance
      options:
         # Need to fix fmt.cxx_deref
         wrap_lua: False

    - decl: Class1 * returnThis();
      return_this: True
      doxygen:
         brief: Return pointer to 'this' to allow chaining calls
      options:
         wrap_python: False
         wrap_lua: False
  
    - decl: Class1 * returnThisBuffer(std::string & name +intent(in), bool flag);
      # do not set return_this
      # passing in a string will cause node.generated_suffix to be set to '_buf'.
      # but result is not bufferified so look for c_statements['result'], not
      # 'result_buf'.

      # The bool argument tests that wrapf.py does not use _generated_suffix
      # since it only applies to the generated C function.

      doxygen:
         brief: Return pointer to 'this' to allow chaining calls
      options:
         wrap_python: False
         wrap_lua: False
  
    - decl: enum DIRECTION { UP = 2, DOWN, LEFT= 100, RIGHT };
  
    - decl: DIRECTION directionFunc(DIRECTION arg);
  
##################################################

  - decl: Class1::DIRECTION directionFunc(Class1::DIRECTION arg);
  
  - decl: int useclass(const Class1 *arg1) 
    options:
      wrap_lua: False
  
# parser does not recognized **
#- decl: void getclass(const Class1 **arg1) 
#  options:
#    wrap_python: False
#    wrap_lua: False
  
  - decl: const Class1 *getclass2() 
    options:
      # const issues with python
      wrap_python: False
      wrap_lua: False
  
  - decl: Class1 *getclass3() 
    options:
#    wrap_python: False
      wrap_lua: False
  
  - decl: Class1 getClassCopy(int flag)
    doxygen:
         brief: Return Class1 instance by value, uses copy constructor
    options:
      wrap_python: False
      wrap_lua: False
  
  
##################################################
  
  - decl: int callback1(int in, int (*incr)(int));
    options:
      wrap_lua: False
      wrap_python: False
  
##################################################

  - decl: struct1 returnStruct(int i, double d);
    options:
      wrap_lua: False
  - decl: struct1 *returnStructPtr(int i, double d);
    options:
      wrap_lua: False
#  - decl: struct1 *returnStructPtrNew(int i, double d);
#    options:
#      wrap_lua: False
#      wrap_python: False
#  - decl: void freeStruct(struct1 *arg1);
#    options:
#      wrap_lua: False
#      wrap_python: False

  - decl: double acceptStructIn(struct1 arg)
    options:
      wrap_lua: False
      wrap_python: False
  - decl: double acceptStructInPtr(struct1 *arg+intent(in))
    options:
      wrap_lua: False
      wrap_python: False
  - decl: void acceptStructOutPtr(struct1 *arg +intent(out), int i, double d)
    options:
      wrap_lua: False
      wrap_python: False
  - decl: void acceptStructInOutPtr(struct1 *arg +intent(inout))
    options:
      wrap_lua: False
      wrap_python: False

##################################################
# Used with testing
  - decl: const std::string& LastFunctionCalled() +len(30)

##########
  
- decl: class Singleton
  options:
    wrap_lua: false
  declarations:
#  - decl: static Singleton* instancePtr()
  - decl: static Singleton& getReference()
  
  
##################################################
# Files which contain code to be inserted into generated code
splicer:
#  c:
#  -  ctutorialsplicer.c
  f:
  -  ftutorialsplicer.f
