copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.'
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
- 'All rights reserved.'
-
- 'This file is part of Shroud.  For details, see'
- 'https://github.com/LLNL/shroud. Please also read shroud/LICENSE.'
-
- 'Redistribution and use in source and binary forms, with or without'
- 'modification, are permitted provided that the following conditions are'
- 'met:'
-
- '* Redistributions of source code must retain the above copyright'
- '  notice, this list of conditions and the disclaimer below.'
- 
- '* Redistributions in binary form must reproduce the above copyright'
- '  notice, this list of conditions and the disclaimer (as noted below)'
- '  in the documentation and/or other materials provided with the'
- '  distribution.'
-
- '* Neither the name of the LLNS/LLNL nor the names of its contributors'
- '  may be used to endorse or promote products derived from this'
- '  software without specific prior written permission.'
-
- 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS'
- '"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT'
- 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR'
- 'A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE'
- 'LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR'
- 'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,'
- 'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,'
- 'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR'
- 'PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF'
- 'LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING'
- 'NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS'
- 'SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'
-
- '#######################################################################'
#
# Test the many variations of strings
#

library: strings
cxx_header: strings.hpp

options:
  debug: True
  wrap_python: True

declarations:

- decl: void passChar(char status)
  doxygen:
    brief: pass a single char argument as a scalar.

- decl: char returnChar()
  doxygen:
    brief: return a char argument (non-pointer)

########################################
# char * argument

- decl: void passCharPtr(char * dest+intent(out), const char *src)
  doxygen:
    brief: strcpy like behavior
    description: |
      dest is marked intent(OUT) to override the intent(INOUT) default
      This avoid a copy-in on dest.
  options:
    # This copies into 'dest' which must be allocated first
    # and does not work with Python
    wrap_python: False
    wrap_Lua: False

- decl: void passCharPtrInOut(char * s+intent(inout))
  doxygen:
    brief: toupper
    description: |
      Change a string in-place.
      For Python, return a new string since strings are immutable.

########################################

- decl: const char * getCharPtr1()
#  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const char *' as character(*)

- decl: const char * getCharPtr2() +len(30)
#  C_error_pattern: C_char_invalid_name
  doxygen:
    brief: return 'const char *' with fixed size (len=30)

- decl: const char * getCharPtr3()
#  C_error_pattern: C_char_invalid_name
  doxygen:
    brief: return a 'const char *' as argument
  format:
    F_string_result_as_arg: output

########################################
# return std::string

# This tries to call a C wrapper which is not created
#- decl: const string getString4()
#  C_error_pattern: C_invalid_name
#  doxygen:
#    brief: return a 'const string' as argument

- decl: const string getConstStringLen() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string' as argument

- decl: const string getConstStringAsArg()
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string' as argument
  format:
    F_string_result_as_arg: output

- decl: const std::string getConstStringAlloc()

########################################
# return std::string reference

- decl: const string& getConstStringRefPure()
#  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string&' as character(*)

- decl: const string& getConstStringRefLen() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return 'const string&' with fixed size (len=30)

- decl: const string& getConstStringRefAsArg()
  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string&' as argument
  format:
    F_string_result_as_arg: output

- decl: const string& getConstStringRefLenEmpty() +len=30
  C_error_pattern: C_invalid_name
  doxygen:
    brief: Test returning empty string reference

- decl: const std::string& getConstStringRefAlloc()

########################################
# return std::string pointer

- decl: const string * getConstStringPtrLen() +len=30
#  C_error_pattern: C_invalid_name
  doxygen:
    brief: return a 'const string *' as character(*)
  description: |
      It is the caller's responsibility to release the string
      created by the C++ library.
  format:
    C_finalize_buf: delete {cxx_var};

- decl: const std::string * getConstStringPtrAlloc()

- decl: const std::string * getConstStringPtrOwnsAlloc()

########################################

- decl: void acceptStringConstReference(const std::string & arg1)
  doxygen:
    brief: Accept a const string reference
    description: |
       Save contents of arg1.
       arg1 is assumed to be intent(IN) since it is const
       Will copy in.

- decl: void acceptStringReferenceOut(std::string & arg1+intent(out))
  doxygen:
    brief: Accept a string reference
    description: |
       Set out to a constant string.
       arg1 is intent(OUT)
       Must copy out.

- decl: void acceptStringReference(std::string & arg1)
  doxygen:
    brief: Accept a string reference
    description: |
       Append "dog" to the end of arg1.
       arg1 is assumed to be intent(INOUT)
       Must copy in and copy out.

- decl: void acceptStringPointer(std::string * arg1)
  doxygen:
    brief: Accept a string pointer

#- decl: void acceptStringInstance(std::string arg1)
#  doxygen:
#    brief: Accept a string instance

- decl: void returnStrings(std::string & arg1 +intent(out),
                           std::string & arg2 +intent(out))
  doxygen:
    brief: Test Python returning multiple std::string arguments.
  options:
    wrap_c: false
    wrap_fortran: false

- decl: char returnMany(int *arg1 +intent(out))
  doxygen:
    description: |
       Test Py_BuildValue with multiple values.
  options:
    wrap_python: false
    wrap_c: false
    wrap_fortran: false

########################################
# explicit annotations
# Currently explicit len/len_trim conflict with auto generated one and do not compile
# local declarations shadow parameter

- decl: void explicit1(char * name+len_trim(AAlen)+intent(in))
  format:
    C_bufferify_suffix: _BUFFER
# len_trim is added for free because intent(in)

- decl: void explicit2(char * name+len(AAtrim)+intent(out))
# len is added for free because intent(out)
  options:
    # This copies into 'name' which must be allocated first
    # and does not work with Python
    wrap_python: False
    wrap_Lua: False

#- decl: void explicit3(char * name+len(AAlen)+len_trim(AAtrim))
# set names for len/len_trim annotations

################################################################################
# extern "C"  C++ functions

- decl: void CpassChar(char status)
  doxygen:
    brief: pass a single char argument as a scalar, extern "C"
  options:
    C_extern_C: true

- decl: char CreturnChar()
  doxygen:
    brief: return a char argument (non-pointer), extern "C"
  options:
    C_extern_C: true

########################################
# char * argument

- decl: void CpassCharPtr(char * dest+intent(out), const char *src)
  options:
    C_extern_C: true
    # This copies into 'dest' which must be allocated first
    # and does not work with Python
    wrap_python: False
    wrap_Lua: False
  doxygen:
    brief: strcpy like behavior
    description: |
      dest is marked intent(OUT) to override the intent(INOUT) default
      This avoid a copy-in on dest.
      extern "C"

########################################
patterns:
    C_invalid_name: |
        if ({cxx_var}.empty()) {{
            return NULL;
        }}
    # return a blank field string if an error occurs
#    C_invalid_name_buf: |
#        if ({cxx_var}.empty()) {{
#            std::memset({c_var}, ' ', {c_var_len});
#            return;
#        }}

