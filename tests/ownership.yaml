copyright:
- '#######################################################################'
- 'Copyright (c) 2017-2018, Lawrence Livermore National Security, LLC.'
- 'Produced at the Lawrence Livermore National Laboratory'
-
- 'LLNL-CODE-738041.'
- 'All rights reserved.'
-
- 'This file is part of Shroud.  For details, see'
- 'https://github.com/LLNL/shroud. Please also read shroud/LICENSE.'
-
- 'Redistribution and use in source and binary forms, with or without'
- 'modification, are permitted provided that the following conditions are'
- 'met:'
-
- '* Redistributions of source code must retain the above copyright'
- '  notice, this list of conditions and the disclaimer below.'
- 
- '* Redistributions in binary form must reproduce the above copyright'
- '  notice, this list of conditions and the disclaimer (as noted below)'
- '  in the documentation and/or other materials provided with the'
- '  distribution.'
-
- '* Neither the name of the LLNS/LLNL nor the names of its contributors'
- '  may be used to endorse or promote products derived from this'
- '  software without specific prior written permission.'
-
- 'THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS'
- '"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT'
- 'LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR'
- 'A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL LAWRENCE'
- 'LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR'
- 'CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,'
- 'EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,'
- 'PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR'
- 'PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF'
- 'LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING'
- 'NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS'
- 'SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.'
-
- '#######################################################################'


library: ownership
cxx_header: ownership.hpp

options:
  debug: True
  F_module_per_class: False
  wrap_python: True
  wrap_lua: True

declarations:
- decl: class Class1
  declarations:
  - decl: int m_flag +readonly +name(flag)
  - decl: ~Class1()

########################################
# Fortran treats ReturnIntPtr and ReturnIntPtrScalar the same
# Python returns a NumPy array for ReturnIntPtr and
# a scalar for ReturnIntPtrScalar

########################################
# return int scalar

- decl: int * ReturnIntPtrRaw()
  fattrs:
    # value of options.return_scalar_pointer
    deref: raw
  options:
    wrap_fortran: False
    wrap_lua: False
    wrap_python: False

- decl: int * ReturnIntPtrScalar()
  fattrs:
    deref: scalar
  options:
#    return_scalar_pointer: scalar
    wrap_lua: False

- decl: int * ReturnIntPtrPointer()
  fattrs:
    # value of options.return_scalar_pointer
    deref: pointer
  options:
#    return_scalar_pointer: pointer
    wrap_lua: False

########################################
# return int(len) owner(library)

- decl: int * ReturnIntPtrDimRaw(int *len+intent(out)+hidden)
  fattrs:
    deref: raw
    dimension: len
  options:
    wrap_fortran: False
    wrap_lua: False
    wrap_python: False

- decl: int * ReturnIntPtrDimPointer(int *len+intent(out)+hidden)
  fattrs:
    deref: pointer
    dimension: len
  options:
    wrap_lua: False

- decl: int * ReturnIntPtrDimAlloc(int *len+intent(out)+hidden)
  fattrs:
    deref: allocatable
    dimension: len
  options:
    wrap_fortran: False
    wrap_lua: False

- decl: int * ReturnIntPtrDimDefault(int *len+intent(out)+hidden)
  fattrs:
    dimension: len
  options:
    wrap_lua: False
    # without deref attribute, return as a Fortran POINTER
#    return_dimension_pointer: pointer

########################################
# return dimension(len) owner(caller)

- decl: int * ReturnIntPtrDimRawNew(int *len+intent(out)+hidden)
  fattrs:
#    deref: pointer
    dimension: len
    owner: caller
#    C_free_pattern: delete_int_array
  options:
    wrap_fortran: False
    wrap_lua: False
    wrap_python: False

- decl: int * ReturnIntPtrDimPointerNew(int *len+intent(out)+hidden)
  fattrs:
    deref: pointer
    dimension: len
    owner: caller
#    C_free_pattern: delete_int_array
  options:
    wrap_lua: False

- decl: int * ReturnIntPtrDimAllocNew(int *len+intent(out)+hidden)
  fattrs:
    deref: allocatable
    dimension: len
    owner: caller
#    C_free_pattern: delete_int_array
  options:
    wrap_fortran: False
    wrap_lua: False

- decl: int * ReturnIntPtrDimDefaultNew(int *len+intent(out)+hidden)
  fattrs:
    dimension: len
    owner: caller
#    C_free_pattern: delete_int_array
  options:
    wrap_lua: False
    # without deref attribute, return as a Fortran POINTER
#    return_dimension_pointer: pointer

########################################
# class 

- decl: void createClassStatic(int flag)
  options:
#    wrap_python: False
    wrap_lua: False

- decl: Class1 * getClassStatic() +owner(library)
  options:
#    wrap_python: False
    wrap_lua: False

- decl: Class1 * getClassNew(int flag) +owner(caller)
  doxygen:
    brief: Return pointer to new Class1 instance.
  options:
#    wrap_python: False
    wrap_lua: False
  



patterns:
   delete_int_array: |
       int * cxx_ptr = reinterpret_cast<int *>(ptr);
       delete [] cxx_ptr;
